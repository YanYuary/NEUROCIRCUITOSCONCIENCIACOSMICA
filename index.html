<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#FFFFFF" id="themeColorMeta">
    <title>🧠 NeuroChan</title>
    <script src="https://cdn.tailwindcss.com">
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.5/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bcryptjs/2.4.3/bcrypt.min.js" defer></script>
    
    <style>
        /* Importación de fuentes para una tipografía moderna y legible */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        /* Definición de variables CSS para un sistema de diseño flexible y temático */
        :root {
            /* Colores del tema claro */
            --app-bg: #F0F2F5; /* Fondo de la aplicación */
            --card-bg: #FFFFFF; /* Fondo de tarjetas y componentes */
            --text-primary-color: #050505; /* Color de texto principal */
            --text-secondary-color: #65676B; /* Color de texto secundario (descripciones, timestamps) */
            --text-tertiary-color: #8A8D91; /* Color de texto terciario (notas pequeñas, IDs) */
            --border-color-light: #CED0D4; /* Borde ligero */
            --border-color-strong: #BCC0C4; /* Borde más fuerte */
            --divider-color: #E4E6EB; /* Líneas divisorias */
            
            /* Colores corporativos actualizados (púrpura vibrante) */
            --primary-accent-color: #6a0dad; /* Color principal de acento (botones, enlaces, títulos) */
            --primary-accent-hover-color: #590bb3; /* Color de acento al pasar el ratón */
            --danger-color: #E02C4A; /* Color para acciones peligrosas (borrar) */
            --success-color: #31A24C; /* Color para acciones exitosas (tú, guardado) */
            --icon-color: #606770; /* Color por defecto de los iconos */
            --icon-bg-hover: #E4E6EB; /* Fondo de icono al pasar el ratón */
            --button-secondary-bg: #E4E6EB; /* Fondo de botón secundario */
            --button-secondary-text: #050505; /* Texto de botón secundario */
            --button-secondary-hover-bg: #D8DADF; /* Fondo de botón secundario al pasar el ratón */
            --link-color: var(--primary-accent-color); /* Color de enlaces */

            /* Colores del tema oscuro (ajustados para contraste y estética) */
            --dark-app-bg: #18191A;
            --dark-card-bg: #242526;
            --dark-text-primary-color: #E4E6EB;
            --dark-text-secondary-color: #B0B3B8;
            --dark-text-tertiary-color: #A0A3A7;
            --dark-border-color-light: #3E4042;
            --dark-border-color-strong: #4E4F50;
            --dark-divider-color: #3A3B3C;
            --dark-icon-color: #B0B3B8;
            --dark-icon-bg-hover: #3A3B3C;
            --dark-button-secondary-bg: #3A3B3C;
            --dark-button-secondary-text: #E4E6EB;
            --dark-button-secondary-hover-bg: #4E5052;

            /* Variable para compensar el ancho del scrollbar en modales */
            --scrollbar-width: 0px;
        }

        /* Aplicación del tema oscuro mediante una clase en el body */
        body.dark-theme {
            --app-bg: var(--dark-app-bg);
            --card-bg: var(--dark-card-bg);
            --text-primary-color: var(--dark-text-primary-color);
            --text-secondary-color: var(--dark-text-secondary-color);
            --text-tertiary-color: var(--dark-text-tertiary-color);
            --border-color-light: var(--dark-border-color-light);
            --border-color-strong: var(--dark-border-color-strong);
            --divider-color: var(--dark-divider-color);
            --icon-color: var(--dark-icon-color);
            --icon-bg-hover: var(--dark-icon-bg-hover);
            --button-secondary-bg: var(--dark-button-secondary-bg);
            --button-secondary-text: var(--dark-button-secondary-text);
            --button-secondary-hover-bg: var(--dark-button-secondary-hover-bg);
        }

        /* Estilos base del cuerpo */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--app-bg);
            color: var(--text-primary-color);
            overflow-x: hidden; /* Previene scroll horizontal no deseado */
            transition: background-color 0.3s ease-in-out, color 0.3s ease-in-out; /* Transición suave de tema */
        }
        
        /* Nuevo: Evitar el scroll del body cuando un modal está abierto */
        body.modal-open {
            overflow: hidden;
            padding-right: var(--scrollbar-width); /* Compensa el ancho del scrollbar */
        }

        /* Encabezado de la aplicación */
        .app-header {
            background-color: var(--card-bg);
            padding: 0.75rem 1rem;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
            position: sticky; /* Fija el encabezado al hacer scroll */
            top: 0;
            z-index: 100; /* Asegura que esté por encima de otros elementos */
            display: flex; /* Para alinear elementos */
            align-items: center; /* Centrar verticalmente */
            justify-content: space-between; /* Espacio entre el título y otros elementos */
        }

        .app-header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--primary-accent-color);
            text-decoration: none;
            margin-right: auto; /* Empuja el título a la izquierda */
        }
        .app-header h1 a {
            color: inherit; /* Hereda el color del h1 */
            text-decoration: none;
        }
        .app-header h1 a:hover {
            opacity: 0.8;
        }
        
        /* Subtítulo eliminado por petición del usuario */
        .app-header #boardTitle {
            display: none;
        }

        /* Contenedor de selectores de tablero */
        .board-selectors-container {
            margin-bottom: 1.75rem; /* Más espacio */
        }

        .board-selector {
            font-weight: 500;
            padding: 0.625rem 1rem;
            border-radius: 9999px; /* Botones más redondeados */
            border: 1px solid var(--border-color-light);
            background-color: var(--card-bg);
            color: var(--text-secondary-color);
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }

        .board-selector:hover {
            background-color: var(--button-secondary-hover-bg);
            color: var(--text-primary-color);
        }

        .board-selector.active {
            background-color: var(--primary-accent-color);
            color: #FFFFFF;
            font-weight: 600;
            border-color: var(--primary-accent-color);
        }
        .board-selector.active:hover {
            background-color: var(--primary-accent-hover-color);
            border-color: var(--primary-accent-hover-color);
        }

        /* Información del tablero */
        #boardInfo {
            /* Imagen de fondo se establecerá dinámicamente en JS */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            min-height: 200px; /* Asegura que el contenedor tenga altura para la imagen */
            display: flex; /* Para centrar el contenido */
            align-items: center; /* Centrado vertical */
            justify-content: center; /* Centrado horizontal */
            text-align: center; /* Centrar texto */
            padding: 0; /* Eliminar padding por defecto para que el overlay cubra todo */
            
            background-color: var(--card-bg); /* Fallback y para bordes */
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            margin-bottom: 1.25rem; /* Espacio consistente */
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            position: relative; /* Necesario para posicionar el overlay */
            overflow: hidden; /* Asegura que el overlay y el contenido no se salgan */
            width: 100%; /* Asegura que ocupe todo el ancho disponible del contenedor padre */
        }
        #boardInfo .overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.4); /* Capa semi-transparente */
            border-radius: 8px; /* Coincide con el radio del contenedor */
            z-index: 1; /* Por debajo del contenido de texto */
        }
        /* El content-wrapper y su contenido ahora están vacíos por petición del usuario */
        #boardInfo .content-wrapper {
            position: relative;
            z-index: 2; /* Por encima del overlay */
            padding: 1.5rem; /* Padding para el contenido de texto */
        }
        #boardInfo h2, #boardInfo p {
            /* Estos elementos se ocultarán o eliminarán en el HTML/JS */
            display: none;
        }

        /* Dark theme adjustments for boardInfo */
        body.dark-theme #boardInfo {
            border-color: var(--dark-border-color-light);
        }

        /* Tarjeta del formulario de publicación */
        .post-form-card {
            background-color: var(--card-bg);
            border: 1.5px solid var(--border-color-light);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.25rem; /* Espacio consistente */
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .post-form-card .input-field {
            background-color: transparent;
            border: 1px solid var(--border-color-light);
            color: var(--text-primary-color);
            border-radius: 6px;
            padding: 0.625rem 0.75rem;
            width: 100%;
            font-size: 0.9rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .post-form-card .input-field::placeholder {
            color: var(--text-secondary-color);
        }
        .post-form-card .input-field:focus {
            outline: none; /* Eliminar outline por defecto */
            border-color: var(--primary-accent-color);
            box-shadow: 0 0 0 2px rgba(106, 13, 173, 0.2); /* Sombra de enfoque */
        }

        .post-input-area {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
        }
        .post-input-area .avatar {
            flex-shrink: 0;
        }

        .post-input-area .relative.flex-grow {
            position: relative;
        }

        .post-input-area textarea {
            flex-grow: 1;
            background-color: var(--app-bg); 
            border: 1px solid var(--border-color-light);
            color: var(--text-primary-color);
            border-radius: 20px;
            padding: 0.75rem 1rem;
            font-size: 0.95rem;
            resize: none;
            min-height: 40px;
            line-height: 1.3;
            overflow: hidden;
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.2s;
            padding-right: calc(1rem + 36px + 1rem); /* Espacio para el botón de enviar */
        }
        .post-input-area textarea::placeholder {
            color: var(--text-secondary-color);
        }
        .post-input-area textarea:focus {
            outline: none;
            border-color: var(--primary-accent-color);
            box-shadow: 0 0 0 2px rgba(106, 13, 173, 0.2);
            background-color: var(--card-bg);
        }
        .post-input-area textarea:focus.focus\:ring-0 {
            box-shadow: 0 0 0 2px rgba(106, 13, 173, 0.2);
        }

        /* Fila de acciones del post */
        .post-actions-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--divider-color);
            flex-wrap: wrap;
        }
        .post-actions-left, .post-actions-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .post-actions-right {
            margin-left: auto;
        }

        /* Botones de icono */
        .icon-button {
            background-color: var(--button-secondary-bg);
            color: var(--icon-color);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            position: relative;
        }
        .icon-button:hover {
            background-color: var(--button-secondary-hover-bg);
            color: var(--text-primary-color);
        }
        .icon-button svg {
            width: 20px;
            height: 20px;
        }
        .icon-button.submit-button {
            background-color: var(--primary-accent-color);
            color: #FFFFFF;
            right: 1rem;
            transform: translateY(-50%);
            top: 50%;
        }
        .icon-button.submit-button:hover {
            background-color: var(--primary-accent-hover-color);
        }
        .icon-button.submit-button:disabled {
            background-color: var(--button-secondary-bg);
            color: var(--text-secondary-color);
            cursor: not-allowed;
        }

        /* Selector de emojis (solo para perfil, no para texto de post) */
        .emoji-picker {
            display: none; /* Por defecto oculto */
            position: absolute;
            top: 100%;
            right: 0; 
            width: 280px; 
            background-color: var(--card-bg);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 0.75rem; 
            z-index: 50;
            grid-template-columns: repeat(auto-fill, minmax(36px, 1fr)); 
            gap: 0.25rem; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .emoji-picker.active {
            display: grid;
        }
        .emoji-option {
            font-size: 1.5rem; 
            cursor: pointer;
            text-align: center;
            padding: 0.25rem; 
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .emoji-option:hover {
            background-color: var(--icon-bg-hover);
        }

        /* Etiqueta de subida de archivo */
        .file-upload-label {
            display: inline-flex;
            align-items: center;
            padding: 0.625rem 1rem;
            background-color: var(--button-secondary-bg);
            color: var(--button-secondary-text);
            border: 1px solid var(--border-color-light);
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .file-upload-label:hover {
            background-color: var(--button-secondary-hover-bg);
            border-color: var(--border-color-strong);
        }
        .file-upload-label svg { 
            margin-right: 0.5rem;
        }

        /* Botones primarios y secundarios */
        .primary-button {
            background-color: var(--primary-accent-color);
            color: #FFFFFF;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            border: none;
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
        }
        .primary-button:hover {
            background-color: var(--primary-accent-hover-color);
        }
        .primary-button svg {
            margin-right: 0.5rem;
        }

        .secondary-button {
            background-color: var(--button-secondary-bg);
            color: var(--button-secondary-text);
            font-weight: 500;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            border: 1px solid var(--border-color-light);
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            cursor: pointer;
        }
        .secondary-button:hover {
            background-color: var(--button-secondary-hover-bg);
            border-color: var(--border-color-strong);
        }

        /* Estilos de un post individual */
        .post {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            margin-bottom: 0.75rem; /* Espacio consistente */
            padding: 1rem;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            transition: box-shadow 0.2s;
            animation: fadeIn 0.4s ease-out; /* Animación de entrada */
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .post-header {
            display: flex;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .post-avatar { 
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 0.75rem;
            object-fit: cover;
            background-color: var(--app-bg); 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; 
            color: var(--text-primary-color); 
            cursor: pointer;
        }
        .post-userinfo {
            display: flex;
            flex-direction: column;
        }
        .post-username {
            font-weight: 600;
            color: var(--text-primary-color);
            font-size: 0.95rem;
            text-decoration: none; /* Asegura que no haya subrayado por defecto */
        }
        .post-username:hover {
            text-decoration: underline; /* Subrayado al pasar el ratón */
            opacity: 0.8;
        }
        .post-timestamp {
            font-size: 0.8rem;
            color: var(--text-secondary-color);
        }

        .post .post-title { 
            font-size: 1.15rem; 
            font-weight: 600;
            color: var(--primary-accent-color);
            margin-bottom: 0.5rem;
        }
        .post-title-link {
            text-decoration: none;
            color: inherit;
        }
        .post-title-link:hover {
            opacity: 0.8;
            text-decoration: underline; /* Subrayado al pasar el ratón */
        }

        .post-content { 
            font-family: 'Inter', sans-serif; 
            color: var(--text-primary-color);
            font-size: 0.95rem;
            line-height: 1.6; /* Ajustado para mejor legibilidad */
            word-wrap: break-word;
            margin-bottom: 0.75rem;
        }
        .post-content img { 
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            margin-top: 0.75rem;
            border: 1px solid var(--border-color-light);
            cursor: zoom-in;
        }
        .post-image-container { 
            margin: 0.75rem 0;
        }
        /* Imágenes en el tablero principal: ancho completo */
        #postsContainer .post-image-container img {
            width: 100%; 
            height: auto;
            max-height: 500px; 
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color-light);
            cursor: zoom-in;
        }
        /* Imágenes en vista de hilo: tamaño normal, no estiradas */
        #threadContainer .post-image-container img {
            max-width: 100%;
            height: auto;
            object-fit: contain;
            border-radius: 8px;
            border: 1px solid var(--border-color-light);
            cursor: zoom-in;
        }

        /* Acciones del post (reacciones, comentarios) */
        .post-actions {
            display: flex;
            justify-content: space-between; 
            align-items: center;
            padding-top: 0.75rem;
            border-top: 1px solid var(--divider-color);
            margin-top: 1rem;
        }
        .reaction-button {
            background: none;
            border: none;
            color: var(--icon-color);
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
        }
        .reaction-button svg { 
            width: 18px;
            height: 18px;
            margin-right: 0.375rem;
        }
        .reaction-button:hover {
            background-color: var(--icon-bg-hover);
            color: var(--text-primary-color);
        }
        .reaction-button.active {
            color: var(--primary-accent-color);
            font-weight: 600;
        }
        .reaction-button.delete {
            color: var(--danger-color);
        }
         .reaction-button.delete:hover {
            background-color: rgba(224, 44, 74, 0.1);
        }

        /* Estilos generales de modales */
        .modal {
            display: none; 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); 
            z-index: 1000; 
            justify-content: center;
            align-items: center;
        }
        .modal.flex { 
            display: flex;
        }
        .modal-content {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color-light);
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
            max-width: 450px;
            width: 90%;
        }
        .modal-content h3 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary-color);
        }
        .modal-content p {
            font-size: 0.95rem;
            color: var(--text-secondary-color);
            margin-bottom: 1rem;
        }
        .modal-content input[type="password"],
        .modal-content input[type="text"],
        .modal-content textarea {
             background-color: var(--app-bg);
             border: 1px solid var(--border-color-light);
             color: var(--text-primary-color);
             border-radius: 6px;
             padding: 0.625rem;
             margin-bottom: 1rem;
        }
        .modal-content input[type="password"]:focus,
        .modal-content input[type="text"]:focus,
        .modal-content textarea:focus {
            outline: none;
            border-color: var(--primary-accent-color);
            box-shadow: 0 0 0 2px rgba(106, 13, 173, 0.2);
        }
        .modal-content .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }

        /* Panel de administración y botones flotantes */
        .admin-panel {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1001; 
            display: flex; 
            gap: 0.5rem; 
        }
        /* Ocultar panel de administración y audio cuando el modal está abierto */
        body.modal-open .admin-panel,
        body.modal-open #audioToggle {
            display: none !important;
        }

        .admin-toggle {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color-light);
            color: var(--icon-color);
            padding: 0.5rem;
            border-radius: 50%;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .admin-toggle:hover {
            background-color: var(--icon-bg-hover);
            box-shadow: 0 3px 7px rgba(0,0,0,0.15);
        }
        #audioToggle { 
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color-light);
            color: var(--icon-color);
            padding: 0.5rem;
            border-radius: 50%;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
         #audioToggle:hover {
            background-color: var(--icon-bg-hover);
            box-shadow: 0 3px 7px rgba(0,0,0,0.15);
        }
         #audioToggle svg {
            width: 20px; height: 20px;
            color: var(--icon-color);
         }
         .admin-toggle svg, #adminLogoutButton svg {
             width: 20px; height: 20px;
         }
         #adminLogoutButton.admin-toggle {
             color: var(--danger-color);
         }
         #adminLogoutButton.admin-toggle:hover {
             background-color: rgba(224, 44, 74, 0.1);
         }

        /* Indicador de respuesta */
        .reply-indicator {
            margin-left:0;
            padding-left:0.5rem;
            border-left: 3px solid var(--primary-accent-color);
            padding-left: 1rem; 
            margin-left: 0; 
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            background-color: rgba(106, 13, 173, 0.05);
            border-radius: 0 4px 4px 0;
        }
        .reply-link {
            color: var(--link-color);
            text-decoration: none;
            font-weight: 500;
            cursor: pointer;
        }
        .reply-link:hover {
            text-decoration: underline;
            color: var(--primary-accent-hover-color);
        }

        /* Tooltips */
        .tooltip .tooltip-text {
            visibility: hidden;
            background-color: #333; 
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 6px 10px;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 0.8rem; 
            white-space: nowrap;
        }
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        #loadingMessage {
            text-align: center;
            font-size: 1rem; 
            padding: 2rem; 
            color: var(--text-secondary-color);
        }

        /* Estilos para el juego de Tarot */
        #tarotGameContainer {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 1.5rem; 
            margin-top: 1.5rem; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }
        #tarotGameContainer h2 {
            font-size: 1.5rem; 
            font-weight: 600;
            color: var(--text-primary-color);
            text-align: center;
            margin-bottom: 1.5rem;
        }
        #tarotInitialCardContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
            min-height: 150px; 
        }
        .tarot-initial-card {
            width: 100px;
            height: 150px;
            background-color: var(--app-bg);
            border: 2px solid var(--primary-accent-color);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            color: var(--primary-accent-color);
            cursor: pointer; /* Make it clickable */
            transition: transform 0.6s ease-in-out, opacity 0.3s;
            transform-style: preserve-3d;
        }
        .tarot-initial-card.spin { /* Animation for shuffling */
            animation: spinAndFade 1s ease-in-out forwards;
        }
        @keyframes spinAndFade {
            0% { transform: rotateY(0deg) scale(1); opacity: 1; }
            50% { transform: rotateY(180deg) scale(1.1); opacity: 0.8; }
            100% { transform: rotateY(360deg) scale(0.5); opacity: 0; }
        }

        #tarotSpreadContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem; 
            margin-top: 1rem;
            margin-bottom: 1rem;
        }
        .tarot-row {
            display: flex;
            justify-content: center;
            gap: 0.75rem; 
        }
        .tarot-card {
            width: 80px;
            height: 120px;
            border: 1px solid var(--border-color-strong);
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.6s, box-shadow 0.3s;
            perspective: 1000px;
            position: relative;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            transform-style: preserve-3d; 
            opacity: 0; 
            transform: translateY(20px); 
        }
         .tarot-card.placed { 
            animation: cardDealFadeIn 0.4s ease-out forwards; /* Nueva animación para la colocación */
        }
        @keyframes cardDealFadeIn {
            from { opacity: 0; transform: translateY(20px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .tarot-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .tarot-card .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 7px; 
            overflow: hidden;
        }
        .tarot-card .card-back {
            background-color: var(--app-bg); 
            color: var(--text-secondary-color);
            font-size: 2rem;
            transform: rotateY(0deg); 
        }
        .tarot-card .card-front {
            background-color: var(--card-bg); 
            transform: rotateY(180deg); 
            padding: 5px;
            box-sizing: border-box;
        }
        .tarot-card.flipped .card-back {
            transform: rotateY(180deg);
        }
        .tarot-card.flipped .card-front {
            transform: rotateY(0deg);
        }

        .tarot-card img.tarot-image-display {
            max-width: 100%;
            height: auto;
            object-fit: cover; 
            border-radius: 4px;
        }
        .tarot-card .tarot-info-overlay { 
           display: none;
        }

        #tarotCardInfoDisplay {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color-light);
            padding: 1.5rem; 
            border-radius: 8px;
            max-width: 500px;
            margin: 1.5rem auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        #tarotCardInfoDisplay h3 { 
            font-size: 1.3rem; 
            margin-bottom: 0.75rem;
            text-align: center;
            color: var(--text-primary-color);
        }
        #tarotCardInfoDisplay img { 
            max-height: 200px; 
            display:block; 
            margin: 0.75rem auto;
            border-radius: 6px;
            border: 1px solid var(--border-color-light);
        }
        #tarotCardInfoDisplay p { 
            font-size: 0.9rem; 
            margin-bottom: 0.5rem; 
            color: var(--text-secondary-color);
            line-height: 1.4;
        }
         #tarotCardInfoDisplay p strong {
            color: var(--text-primary-color);
         }

        /* Pie de página */
        footer {
            text-align: center;
            padding: 2rem 1rem;
            margin-top: 2rem;
            border-top: 1px solid var(--divider-color);
            font-size: 0.85rem;
            color: var(--text-tertiary-color);
        }
        footer a {
            color: var(--primary-accent-color);
            text-decoration: none;
        }
        footer a:hover {
            text-decoration: underline;
        }

        /* Limpieza de estilos "neon" y "glitch" */
        .glitch, .neon-text:not(.post-title), .neon-border, .neon-button, .crt-effect, .fractal-bg,
        .dream-glow, .tech-glow, .dimension-glow, .transmission-effect {
            animation: none !important;
            text-shadow: none !important;
            box-shadow: none !important;
        }
        
        .neon-border {
            border: 1px solid var(--border-color-light) !important;
        }
        .app-header .neon-text { 
            color: var(--primary-accent-color) !important;
        }
        #boardInfo .neon-text { 
             color: var(--text-primary-color) !important;
             font-weight: 600;
        }

        #submitPost.neon-button { 
            background-color: var(--primary-accent-color);
            color: white;
            border: none;
            box-shadow: none;
        }
         #submitPost.neon-button:hover {
             background-color: var(--primary-accent-hover-color);
         }

        #themeToggle.neon-button { 
             background-color: var(--button-secondary-bg);
             color: var(--button-secondary-text);
             border: 1px solid var(--border-color-light);
             box-shadow: none;
        }
         #themeToggle.neon-button:hover {
             background-color: var(--button-secondary-hover-bg);
             border-color: var(--border-color-strong);
        }

        /* Estilos de tema oscuro para componentes específicos */
        body.dark-theme .post,
        body.dark-theme .post-form-card,
        body.dark-theme #boardInfo,
        body.dark-theme .modal-content,
        body.dark-theme .admin-toggle,
        body.dark-theme #audioToggle,
        body.dark-theme .app-header,
        body.dark-theme .board-selector,
        body.dark-theme #tarotGameContainer,
        body.dark-theme #tarotCardInfoDisplay,
        body.dark-theme .image-viewer-content,
        body.dark-theme .stories-container {
            border-color: var(--dark-border-color-light);
        }
        body.dark-theme .post-form-card .input-field,
        body.dark-theme .post-input-area textarea,
        body.dark-theme .modal-content input[type="password"],
        body.dark-theme .modal-content input[type="text"],
        body.dark-content textarea { /* Corregido: body.dark-theme .modal-content textarea */
             background-color: var(--dark-app-bg);
             border-color: var(--dark-border-color-strong);
        }
        body.dark-theme .post-input-area textarea:focus {
            background-color: var(--dark-card-bg);
        }

        body.dark-theme .board-selector:not(.active) {
            color: var(--dark-text-secondary-color);
            background-color: var(--dark-card-bg);
        }
        body.dark-theme .board-selector:not(.active):hover {
             background-color: var(--dark-button-secondary-hover-bg);
             color: var(--dark-text-primary-color);
        }
         body.dark-theme .file-upload-label {
             background-color: var(--dark-button-secondary-bg);
             color: var(--dark-button-secondary-text);
             border-color: var(--dark-border-color-strong);
         }
         body.dark-theme .file-upload-label:hover {
             background-color: var(--dark-button-secondary-hover-bg);
             border-color: var(--dark-border-color-strong);
         }

        /* Mejoras en el enfoque visual para accesibilidad */
        button:focus-visible, input:focus-visible, textarea:focus-visible, [tabindex]:focus-visible:not([tabindex="-1"]) {
            outline: 2px solid var(--primary-accent-color);
            outline-offset: 2px;
            box-shadow: 0 0 0 3px rgba(106, 13, 173, 0.3);
        }
        .post-form-card input:focus-visible, 
        .post-form-card textarea:focus-visible,
        .modal-content input:focus-visible,
        .modal-content textarea:focus-visible {
            outline: none; /* Eliminar el outline por defecto para usar nuestro box-shadow */
        }

        /* Avatar */
        .avatar { 
            filter: none; 
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem; 
            background-color: var(--app-bg); 
            color: var(--text-primary-color);
            cursor: pointer;
        }
        
        /* Previsualización de escritura - ELIMINADO */
        #typingPreview {
            display: none !important; 
        }

        /* Estilos de búsqueda y botón aleatorio */
        .search-input-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
            gap: 0.5rem;
            transition: width 0.3s ease-out, opacity 0.3s ease-out;
            width: 0;
            opacity: 0;
            overflow: hidden;
            flex-shrink: 1;
        }

        .search-input-container.active {
            width: 100%;
            opacity: 1;
        }

        #postSearchInput {
            flex-grow: 1;
            background-color: var(--app-bg);
            border: 1px solid var(--border-color-light);
            color: var(--text-primary-color);
            border-radius: 20px;
            padding: 0.625rem 1rem;
            font-size: 0.9rem;
            transition: border-color 0.2s, box-shadow 0.2s, background-color 0.2s;
            min-width: 100px;
        }
        #postSearchInput::placeholder {
            color: var(--text-secondary-color);
        }
        #postSearchInput:focus {
            outline: none;
            border-color: var(--primary-accent-color);
            box-shadow: 0 0 0 2px rgba(106, 13, 173, 0.2);
            background-color: var(--card-bg);
        }

        #randomPostButton {
            font-size: 1.2rem;
            padding: 0.5rem;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--button-secondary-bg);
            color: var(--button-secondary-text);
            border: 1px solid var(--border-color-light);
            transition: background-color 0.2s, border-color 0.2s;
            cursor: pointer;
        }
        #randomPostButton:hover {
            background-color: var(--button-secondary-hover-bg);
            border-color: var(--border-color-strong);
        }
        body.dark-theme #postSearchInput {
            background-color: var(--dark-app-bg);
            border-color: var(--dark-border-color-strong);
        }
        body.dark-theme #postSearchInput:focus {
            background-color: var(--dark-card-bg);
        }
        body.dark-theme #randomPostButton {
            background-color: var(--dark-button-secondary-bg);
            color: var(--dark-button-secondary-text);
            border-color: var(--dark-border-color-strong);
        }
        body.dark-theme #randomPostButton:hover {
            background-color: var(--dark-button-secondary-hover-bg);
            border-color: var(--dark-border-color-strong);
        }

        /* Tooltip para el botón aleatorio */
        .tooltip-random {
            position: relative;
            display: inline-block;
        }

        .tooltip-random .tooltiptext {
            visibility: hidden;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        .tooltip-random:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Estilos específicos del modal de visualización de imágenes */
        .modal-content.image-viewer-content {
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            position: relative;
            overflow-y: auto;
            box-sizing: border-box;
        }

        #enlargedImage {
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            border-radius: 8px;
            border: 1px solid var(--border-color-light);
            margin-bottom: 1rem;
        }

        .image-viewer-content .close-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: rgba(0, 0, 0, 0.4);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: background-color 0.2s;
        }
        .image-viewer-content .close-button:hover {
            background: rgba(0, 0, 0, 0.6);
        }
        /* Botón de descarga */
        .image-viewer-content #downloadImageButton {
            right: 2.5rem; /* Ajustado para no superponerse con el botón de cerrar */
        }
        
        /* Contenedor de reacciones en el visor de imágenes */
        #imageViewerReactionsContainer {
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--divider-color);
            margin-top: 1rem;
            background-color: var(--card-bg);
            border: 1.5px solid var(--border-color-light);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        body.dark-theme #imageViewerReactionsContainer {
            background-color: var(--dark-card-bg);
            border-color: var(--dark-border-color-strong);
        }

        /* Estilos de Historias */
        #storiesContainer {
            display: flex;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x mandatory;
            gap: 0.75rem;
            padding: 0.5rem 0.5rem;
            margin-bottom: 1.25rem; /* Espacio consistente */
            border-radius: 12px;
            background-color: var(--card-bg);
            border: 1.5px solid var(--border-color-light);
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            -ms-overflow-style: none;
            scrollbar-width: none;
            cursor: grab; /* Indica que es arrastrable */
        }
        #storiesContainer.active {
            cursor: grabbing; /* Indica que se está arrastrando */
        }
        #storiesContainer::-webkit-scrollbar {
            display: none;
        }

        .story-item {
            flex-shrink: 0;
            width: 80px;
            height: 120px;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            scroll-snap-align: start;
            border: 2px solid transparent;
            transition: border-color 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .story-item:hover {
            border-color: var(--primary-accent-color);
        }
        .story-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: brightness(0.8);
        }
        .story-author-name {
            position: absolute;
            bottom: 0.25rem;
            left: 0;
            right: 0;
            color: white;
            font-size: 0.7rem;
            font-weight: 600;
            text-align: center;
            padding: 0.25rem 0;
            background: linear-gradient(to top, rgba(0,0,0,0.7), rgba(0,0,0,0));
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            word-break: break-word;
            white-space: normal;
        }

        /* Diseño responsivo */
        @media (min-width: 1024px) {
            .container {
                /* Ajuste de ancho del contenedor para posts un 15% más anchos */
                max-width: 1472px; /* 1280px * 1.15 */ 
                padding-left: 1rem; /* Keep some padding */
                padding-right: 1rem; /* Keep some padding */
            }
            #boardInfo {
                /* Adjust negative margins to push it out into the new wider container */
                margin-left: -1rem; /* Compensate for container's px-4 (1rem) */
                margin-right: -1rem; /* Compensate for container's px-4 (1rem) */
            }
            #postsContainer {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }
        @media (max-width: 1023px) {
            .container {
                padding-left: 0;
                padding-right: 0;
            }
            #postsContainer {
                grid-template-columns: repeat(1, minmax(0, 1fr));
                gap: 0;
            }
            .post {
                border-radius: 0;
                margin-left: 0;
                margin-right: 0;
            }
            .post-form-card, #storiesContainer, #boardInfo {
                border-radius: 0;
                margin-left: 0;
                margin-right: 0;
            }
            .app-header {
                border-radius: 0;
            }
        }
    
    /* v1.2 minimal indentation for nested comments */
    .comment-header{margin-left:0.25rem}
    .comment-body{margin-left:1.5rem}

    .comment-container { margin-left: 0.5rem; }
    /* .comment-header { margin-left: 0rem; } /* No es necesario, ya que .post-header no tiene margen izquierdo por defecto */

</style>
</head>
<body class="min-h-screen"> 
    <header class="app-header">
        <h1><a href="#board=social" aria-label="Ir al tablero principal /social/" id="neuroChanTitle">🧠 NeuroChan</a></h1>
        <div class="flex items-center gap-2">
            <button id="settingsToggle" class="admin-toggle" aria-label="Configuración">
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5"><path fill-rule="evenodd" d="M11.078 2.25c-.217-.065-.437-.12-.65-.173a1.75 1.75 0 00-1.946.002c-.213.053-.433.108-.65.173C5.77 3.072 4.5 5.25 4.5 7.5c0 1.97.823 3.717 2.096 4.904.284.344.468.756.528 1.186a3.5 3.5 0 00.878 2.033L9.18 16.06a1.75 1.75 0 002.64 0l.178-.445a3.5 3.5 0 00.878-2.033c.06-.43.243-.842.528-1.186C14.677 11.217 15.5 9.47 15.5 7.5c0-2.25-1.27-4.428-3.344-5.078zM10 9.5a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" /></svg>
            </button>
            <button id="infoToggle" class="admin-toggle" aria-label="Información del sitio">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" /></svg>
            </button>
            <button id="adminLogoutButton" class="admin-toggle" style="display: none;" aria-label="Cerrar sesión de administrador">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                </svg>
            </button>
        </div>
    </header>

    <div class="container mx-auto max-w-7xl px-4 py-2 md:py-4"> 
        <div id="boardInfo" class="mb-8 relative overflow-hidden w-full"> 
            <div class="overlay"></div> <div class="content-wrapper">
                </div>
            <div id="boardCoverUploadArea" class="absolute top-2 right-2 z-30 flex gap-2" style="display: none;">
                <label for="boardCoverUploadInput" class="icon-button bg-gray-700 hover:bg-gray-800 text-white opacity-80 hover:opacity-100 transition-opacity" title="Subir nueva imagen de portada">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
                    </svg>
                    <span class="sr-only">Subir portada</span>
                </label>
                <input type="file" id="boardCoverUploadInput" class="hidden" accept="image/*">
                <button id="selectExistingCoverButton" class="icon-button bg-gray-700 hover:bg-gray-800 text-white opacity-80 hover:opacity-100 transition-opacity" title="Seleccionar portada existente">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l1.5 1.5m1.5-1.5l-1.5-1.5m1.5 1.5L2.25 15.75m6.75-6.75l1.5 1.5m1.5-1.5l-1.5-1.5m1.5 1.5L9 9m6.75-6.75l1.5 1.5m1.5-1.5l-1.5-1.5m1.5 1.5L15.75 3m6.75 6.75l1.5 1.5m1.5-1.5l-1.5-1.5m1.5 1.5L21.75 9" />
                    </svg>
                </button>
                <div id="boardCoverUploadLoading" class="hidden absolute top-0 left-0 w-full h-full flex items-center justify-center bg-black bg-opacity-50 rounded-lg">
                    <svg class="animate-spin h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                </div>
            </div>
        </div>

        <div class="board-selectors-container flex flex-wrap gap-2 mb-6 justify-center">
            <button class="board-selector active" data-board="social" aria-label="Tablero social">
                /social/
            </button>
            <button class="board-selector" data-board="neuro" aria-label="Tablero neuro">
                /neuro/
            </button>
            <button class="board-selector" data-board="energia" aria-label="Tablero energía">
                /energía/
            </button>
            <button class="board-selector" data-board="fungis" aria-label="Tablero fungis">
                /fungis/
            </button>
            <button class="board-selector" data-board="tarot" aria-label="Tablero tarot">
                /tarot/
            </button>
            <button class="board-selector" data-board="lucidum" aria-label="Tablero lucidum">
                /lucidum/
            </button>
            <button class="board-selector" data-board="matrix" aria-label="Tablero matrix">
                /matrix/
            </button>
            <button class="board-selector" data-board="guerra" aria-label="Tablero guerra">
                /guerra/
            </button>
        </div>

        <div id="postFormContainer" class="post-form-card relative"> 
            <div class="post-input-area mb-2">
                <div id="mainPostAvatar" class="avatar"></div>
                <div class="relative flex-grow">
                    <textarea
                        id="postContent"
                        class="w-full focus:ring-0" 
                        rows="1"
                        placeholder="¿Qué estás pensando...?"
                        aria-label="Contenido del post"></textarea>
                    <button id="submitPost" class="icon-button submit-button absolute bottom-2" aria-label="Enviar post">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 16.571V11a1 1 0 112 0v5.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>
                    </button>
                </div>
            </div>
            
            <div class="post-actions-row">
                <div class="post-actions-left">
                    <button id="searchToggle" class="icon-button" aria-label="Abrir buscador">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5"><path fill-rule="evenodd" d="M9 3.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zM2 9a7 7 0 1112.452 4.391l3.328 3.329a.75.75 0 11-1.06 1.06l-3.329-3.328A7 7 0 012 9z" clip-rule="evenodd" /></svg>
                    </button>
                    <div class="search-input-container">
                        <input type="text" id="postSearchInput" placeholder="Buscar..." aria-label="Buscar posts">
                    </div>
                    <div class="tooltip-random">
                        <button id="randomPostButton" aria-label="Ir a un post aleatorio">🎲</button>
                        <span class="tooltiptext">Post Aleatorio</span>
                    </div>
                </div>
                <div class="post-actions-right">
                    <label for="fileUpload" class="icon-button" aria-label="Subir imagen">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" /></svg>
                    </label>
                    <input type="file" id="fileUpload" class="hidden" accept="image/*" aria-hidden="true">
                    <span id="fileName" class="text-xs text-gray-500 ml-2 self-center"></span>
                    
                    <button id="postPasswordToggle" class="icon-button" aria-label="Establecer contraseña para el post">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M11.078 2.25c-.217-.065-.437-.12-.65-.173a1.75 1.75 0 00-1.946.002c-.213.053-.433.108-.65.173C5.77 3.072 4.5 5.25 4.5 7.5c0 1.97.823 3.717 2.096 4.904.284.344.468.756.528 1.186a3.5 3.5 0 00.878 2.033L9.18 16.06a1.75 1.75 0 002.64 0l.178-.445a3.5 3.5 0 00.878-2.033c.06-.43.243-.842.528-1.186C14.677 11.217 15.5 9.47 15.5 7.5c0-2.25-1.27-4.428-3.344-5.078zM10 9.5a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" /></svg>
                    </button>
                </div>
            </div>
            </div>
        
        <div id="storiesContainer" class="stories-container">
            </div>

        <div id="loadingMessage" class="hidden">Cargando transmisiones...</div>

        <div id="postsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-4">
            </div>

        <div id="threadContainer" class="hidden mt-8">
            </div>
        
        <div id="tarotGameContainer" class="hidden flex flex-col items-center p-4">
            <h2 class="text-2xl font-semibold mb-6">Lectura de Tarot Piramidal</h2>
            <div id="tarotInitialCardContainer" class="mb-6">
                <div id="tarotDeckCard" class="tarot-initial-card">🔮</div>
            </div>
            <div class="mb-6 flex gap-4">
                <button id="shuffleTarotButton" class="primary-button">Barajar y Tirar Cartas</button>
                </div>
            <div id="tarotSpreadContainer" class="grid gap-2 justify-items-center w-full">
                </div>
            <div id="tarotCardInfoDisplay" class="hidden mt-6 p-6 w-full md:max-w-2xl rounded-lg">
                <h3 id="tarotCardNameInfo" class="text-xl font-semibold text-center mb-3"></h3>
                <img id="tarotCardImageInfo" src="#" alt="Carta del Tarot Seleccionada" class="mx-auto my-3 max-h-60 rounded"/>
                <div class="text-sm space-y-2">
                    <p><strong>Posición:</strong> <span id="tarotPositionInfo"></span></p>
                    <p><strong>Significado (Derecha):</strong> <span id="tarotMeaningUpInfo"></span></p>
                    <p><strong>Significado (Invertida):</strong> <span id="tarotMeaningRevInfo"></span></p>
                    <p><strong>Pregunta Clave:</strong> <span id="tarotQuestionInfo"></span></p>
                </div>
            </div>
        </div>

        <div class="fixed bottom-4 right-4">
            <button id="audioToggle" aria-label="Alternar audio">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072M12 6a7.975 7.975 0 0115.657 2.343m0 0a7.975 7.975 0 010 11.314m-11.314 0a7.975 7.975 0 010-11.314m0 0a7.975 7.975 0 0115.657-2.343" />
                </svg>
            </button>
        </div>
    </div>

    <audio id="bgAudio" loop>
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-1699.mp3" type="audio/mpeg">
    </audio>

    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold">Configuración</h3>
                <button id="closeSettingsModal" class="text-2xl font-bold leading-none hover:text-gray-700">&times;</button>
            </div>
            <div class="space-y-4" id="settingsModalContent">
                <button id="themeToggleModalButton" class="secondary-button w-full">Cambiar Tema</button>

                <div id="adminControlAreaSettings">
                    <button id="adminLoginModalButton" class="secondary-button w-full">Iniciar Sesión como Administrador</button>
                    <button id="adminLogoutFromSettingsButton" class="secondary-button w-full" style="background-color: var(--danger-color); display: none; color: white;">Cerrar Sesión de Administrador</button>
                </div>

                <div id="adminPasswordInputAreaSettings" class="mt-4 pt-4 border-t border-[var(--divider-color)]" style="display: none;">
                    <h4 class="text-md font-semibold mb-2">Acceso de Administrador</h4>
                    <label for="adminPasswordSettingsInput" class="block text-sm mb-1">Contraseña Maestra:</label>
                    <input type="password" id="adminPasswordSettingsInput" class="w-full p-2 mb-3 modal-input"> <div class="flex gap-2 mt-2">
                        <button id="cancelAdminLoginSettings" class="secondary-button flex-1">Cancelar</button>
                        <button id="confirmAdminLoginSettings" class="primary-button flex-1" style="background-color: var(--success-color);">Acceder</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="postPasswordModal" class="modal">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 id="postPasswordModalTitle" class="text-xl font-semibold">Configuración de Post</h3>
                <button id="closePostPasswordModal" class="text-2xl font-bold leading-none hover:text-gray-700">&times;</button>
            </div>
            <p id="postPasswordModalMessage" class="mb-4 text-sm">Establece un nombre (opcional) y una contraseña (opcional) para poder editar o borrar este post en el futuro.</p>
            
            <div id="postPasswordModalNameTitleFields" class="mb-3"> <label for="postPasswordModalNameInput" class="block text-sm mb-1">Tu Nombre (opcional):</label>
                <input type="text" id="postPasswordModalNameInput" class="w-full p-2 mb-3" maxlength="30" placeholder="Anónimo">
                
                <label for="postPasswordModalTitleInput" class="block text-sm mb-1">Título del Post (opcional):</label>
                <input type="text" id="postPasswordModalTitleInput" class="w-full p-2 mb-3" maxlength="100" placeholder="Título del post">
            </div>

            <label for="postPasswordModalInput" class="block text-sm mb-1">Contraseña (opcional):</label>
            <input type="password" id="postPasswordModalInput" class="w-full p-2 mb-4">
            <div class="modal-actions">
                <button id="cancelPostPassword" class="secondary-button">Cancelar</button>
                <button id="confirmPostPassword" class="primary-button">Aceptar</button>
            </div>
        </div>
    </div>

    <div id="profileEmojiPickerModal" class="modal">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold">Elige tu Avatar Emoji</h3>
                <button id="closeProfileEmojiPickerModal" class="text-2xl font-bold leading-none hover:text-gray-700">&times;</button>
            </div>
            <div id="profileEmojiGrid" class="grid grid-cols-6 gap-2 text-center">
                </div>
        </div>
    </div>


    <div id="deleteModal" class="modal">
        <div class="modal-content">
            <h3 class="text-xl mb-4">Confirmar borrado</h3>
            <p class="mb-4">Introduce la contraseña para borrar este post:</p>
            <input type="password" id="deletePasswordInput" class="w-full p-2 mb-4"> 
            <div class="modal-actions">
                <button id="cancelDelete" class="secondary-button">Cancelar</button>
                <button id="confirmDelete" class="primary-button" style="background-color: var(--danger-color);">Borrar</button>
            </div>
        </div>
    </div>

    <div id="editModal" class="modal">
        <div class="modal-content max-w-md"> <h3 class="text-xl mb-4">Editar Transmisión</h3>
            
            <div id="editPasswordPromptContainer" class="mb-4" style="display: none;">
                <label for="editPostPasswordPrompt" class="block mb-1 text-sm">Contraseña del Post (para editar):</label>
                <input type="password" id="editPostPasswordPrompt" class="w-full p-2">
            </div>

            <label for="editPostName" class="block mb-1 text-sm">Nombre:</label>
            <input id="editPostName" class="w-full p-2 mb-2" maxlength="30">

            <label for="editPostTitle" class="block mb-1 text-sm">Título:</label>
            <input id="editPostTitle" class="w-full p-2 mb-2" maxlength="100">

            <label for="editPostContent" class="block mb-1 text-sm">Contenido:</label>
            <textarea id="editPostContent" class="w-full p-3 mb-2" rows="4"></textarea>

            <div class="mb-2">
                <img id="editImagePreview" src="#" alt="Previsualización de imagen" class="max-h-40 mb-2" style="display:none; border: 1px solid var(--border-color-light); border-radius: 6px;">
                <label for="editFileUpload" class="file-upload-label px-3 py-1 text-xs cursor-pointer rounded mr-2">
                    Cambiar Imagen
                </label>
                <input type="file" id="editFileUpload" class="hidden" accept="image/*">
                <span id="editFileName" class="text-xs text-gray-500"></span>
                <label class="ml-2 text-xs"><input type="checkbox" id="removeCurrentImage"> Remover Imagen Actual</label>
            </div>

            <label for="editNewPostPassword" class="block mb-1 text-sm">Nueva Contraseña (opcional, dejar en blanco para no cambiar):</label>
            <input type="password" id="editNewPostPassword" class="w-full p-2 mb-4">
            <div class="modal-actions">
                <button id="cancelEdit" class="secondary-button">Cancelar</button>
                <button id="confirmEdit" class="primary-button" style="background-color: var(--success-color);">Guardar Cambios</button>
            </div>
        </div>
    </div>

    <div id="infoModal" class="modal">
        <div class="modal-content max-w-lg"> <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl">Acerca de NeuroChan</h3>
                <button id="closeInfoModal" class="text-2xl font-bold leading-none hover:text-gray-700">&times;</button>
            </div>
            <p class="mb-4 text-sm">
                NeuroChan es un espacio para la comunidad espiritual de los "Fungis": aquellos que exploran la conciencia, 
                desafían los metaprogramas del ego que operan en nuestros neurocircuitos y encuentran sabiduría en herramientas como el tarot.
            </p>
            <p class="mb-4 text-sm">
                Aquí puedes compartir tus experiencias con "inochis" (seres o energías), encuentros con entidades inorgánicas, 
                la naturaleza del ego, despertares de conciencia y cualquier tema relacionado con la expansión de la mente y el espíritu.
            </p>
            <h4 class="text-lg mb-2 font-semibold">Reglas del Sitio (Guías Espirituales):</h4>
            <ul class="list-disc list-inside text-sm space-y-1 mb-4">
                <li>Respeta todas las perspectivas y experiencias. El camino espiritual es único para cada ser.</li>
                <li>No se tolera el proselitismo ni la imposición de creencias. Comparte, no conviertas.</li>
                <li>Mantén un lenguaje consciente y evita ataques personales. La crítica constructiva es bienvenida, el odio no.</li>
                <li>Este es un espacio para la exploración y el aprendizaje mutuo. Sé abierto y curioso.</li>
                <li>La información compartida es para reflexión personal y no sustituye el consejo profesional (médico, psicológico, etc.) cuando sea necesario.</li>
            </ul>
            <p class="text-xs text-gray-500">Recuerda: la verdadera sabiduría reside en el corazón y en la experiencia directa.</p>
        </div>
    </div>

    <div id="genericModal" class="modal">
        <div class="modal-content">
            <h3 id="genericModalTitle" class="text-xl mb-4">Mensaje</h3>
            <p id="genericModalMessage" class="mb-4">Este es un mensaje de ejemplo.</p>
            <div id="genericModalButtons" class="modal-actions">
                <button class="secondary-button generic-modal-close-button">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="imageViewerModal" class="modal">
        <div class="modal-content image-viewer-content">
            <button id="downloadImageButton" class="close-button" aria-label="Descargar imagen">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
                </svg>
            </button>
            <button id="closeImageViewerModal" class="close-button">&times;</button>
            <img id="enlargedImage" src="" alt="Enlarged Post Image" class="w-full h-auto max-h-[70vh] object-contain rounded-lg mb-4"/>
            <div id="imageViewerReactionsContainer" class="flex gap-1 items-center flex-wrap"> 
                <button class="reaction-button heart-reaction-button flex items-center gap-1" aria-label="Reaccionar con Corazón">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" /></svg>
                    <span class="count">0</span>
                </button>
                <button class="reaction-button funny-reaction-button flex items-center gap-1" aria-label="Reaccionar con Me Diverte">
                    😂 <span class="count">0</span>
                </button>
                <button class="reaction-button angry-reaction-button flex items-center gap-1" aria-label="Reaccionar con Me Enoja">
                    😠 <span class="count">0</span>
                </button>
            </div>
        </div>
    </div>

    <div id="selectCoverModal" class="modal">
        <div class="modal-content max-w-2xl">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold">Seleccionar Portada Existente</h3>
                <button id="closeSelectCoverModal" class="text-2xl font-bold leading-none hover:text-gray-700">&times;</button>
            </div>
            <div id="existingCoversGrid" class="grid grid-cols-2 md:grid-cols-3 gap-4 max-h-96 overflow-y-auto p-2 border border-gray-300 rounded-lg">
                <p class="text-center text-gray-500 col-span-full">Cargando portadas...</p>
            </div>
            <div class="modal-actions mt-4">
                <button id="cancelSelectCover" class="secondary-button">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="confirmDeleteCoverModal" class="modal">
        <div class="modal-content">
            <h3 class="text-xl mb-4">Confirmar Borrado de Portada</h3>
            <p class="mb-4">¿Estás seguro de que quieres borrar esta portada? Esta acción no se puede deshacer.</p>
            <img id="deleteCoverPreview" src="" alt="Portada a borrar" class="max-h-40 mx-auto my-3 rounded-lg border border-gray-300" style="display:none;">
            <div class="modal-actions">
                <button id="cancelDeleteCover" class="secondary-button">Cancelar</button>
                <button id="confirmDeleteCover" class="primary-button" style="background-color: var(--danger-color);">Borrar</button>
            </div>
        </div>
    </div>

    <footer class="app-footer">
        <p>&copy; <span id="currentYear"></span> NeuroChan. Todos los derechos reservados a la Madre Tierra y sus habitantes conscientes.</p>
        <p>Un espacio para la exploración libre del Ser.</p>
    </footer>

    <script type="module">
        // Importación de módulos de Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getFirestore, collection, addDoc, onSnapshot, 
            doc, deleteDoc, updateDoc, query, where, increment, 
            serverTimestamp, getDoc, getDocs, setDoc
            } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        import { 
            getAuth, signInAnonymously, onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        // Carga de bcrypt.js de forma robusta
        let bcryptInstance;
        if (typeof bcrypt !== 'undefined') {
            bcryptInstance = bcrypt;
        } else if (globalThis.dcodeIO && globalThis.dcodeIO.bcrypt) {
            bcryptInstance = globalThis.dcodeIO.bcrypt;
        } else {
            console.error("Bcrypt.js no está cargado. Las funciones de contraseña no funcionarán.");
        }
        
        // Configuración de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyDQ6q9KkYS0To-BJEjxQSQUyQ65C6wam6o", // Reemplaza con tu API Key real
            authDomain: "neurocircuitos.firebaseapp.com", // Reemplaza con tu Auth Domain real
            projectId: "neurocircuitos", // Reemplaza con tu Project ID real
            storageBucket: "neurocircuitos.appspot.com", // Reemplaza con tu Storage Bucket real
            messagingSenderId: "988092454441", // Reemplaza con tu Messaging Sender ID real
            appId: "1:988092454441:web:e260431acea58ada5f2e38", // Reemplaza con tu App ID real
            measurementId: "G-9678SEZ792" // Opcional: Reemplaza con tu Measurement ID real
        };

    // --- Board migration map added in v1.2
    const BOARD_MIGRATION = {
        meta: 'social',
        sueños: 'neuro',
        tecnosoma: 'fungis',
        retro: 'lucidum',
        // 'tarot' ya es el nombre nuevo, no necesita migración
    };

    // Reverse mapping to access legacy board names when querying
    const BOARD_REVERSE = Object.fromEntries(Object.entries(BOARD_MIGRATION).map(([oldB,newB])=>[newB,oldB]));

    function mapLegacyBoard(board){
        return BOARD_MIGRATION[board] ?? board;
    }

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const postsCollectionRef = collection(db, "Posts");
        const coversCollectionRef = collection(db, "Portadas"); 

        // IIFE para encapsular el código y evitar variables globales no deseadas
        (function() {
            const MAX_IMAGE_SIZE = 4 * 1024 * 1024; // 4 MB, ajustado para permitir imágenes un poco más grandes
            const ADMIN_HASH = '$2a$12$g6.0Q/OD2nEKC6zSQlkBGuh70mJPkd9SlMVWIbWKGlYAPe0m/RcKi'; // Contraseña de administrador hasheada

            // Emojis disponibles solo para avatares de perfil
            const AVATARS = [ 
                '👾', '🤖', '👹', '👻', '💀', '👽', '🎮', '🕹️', '🔮', '🧿',
                '👁️', '🧠', '🦾', '🦿', '🧬', '🔭', '🛸', '🌌', '🌀', '🌠'
            ];

            // Objeto de estado global de la aplicación
            let state = {
                currentBoard: 'social', 
                currentTheme: localStorage.getItem('neurochan_theme') || 'light', 
                audioEnabled: false, 
                isAdmin: localStorage.getItem('neurochan_admin') === 'true', 
                replyTo: null, 
                currentDeletePostId: null, 
                allPostsData: {}, 
                allRootPosts: [], 
                currentEditPostId: null, 
                currentEditPostData: null, 
                viewingThreadId: null, 
                tarotDeck: [], 
                tarotSpread: [], 
                tarotCardInfoVisible: false, 
                tarotInitialCardFlipped: false, 
                tempPostPassword: null, 
                tempPostName: null,    
                tempPostTitle: null, 
                currentPostAvatar: null, 
                profileEmojiPickerTarget: null, 
                scrollAfterReply: null, 
                directChildrenCounts: {}, 
                imageViewerCurrentPostId: null, 
                unsubscribeImageViewer: null, 
                unsubscribeCover: null, 
                allCoversData: {}, 
                currentCoverToDelete: null,
                isPostPasswordModalOpenForReply: false, // CORRECCIÓN: Bandera para modal de contraseña en respuestas
            };

            // Datos de los tableros (actualizados)
            const boards = {
                social: { 
                    title: "/social/ - Metaprogramación y Viaje Dimensional", 
                    description: "Temas: Neurocircuitos, Egocuerpos, Realidades Paraleles, Estética Retro Anime", 
                    footer: "Todos los posts son persistentes y se sincronizan en tiempo real.",
                    coverImage: "https://raw.githubusercontent.com/YanYuary/NEUROCIRCUITOSCONCIENCIACOSMICA/main/b7f01798-8ce8-427e-8a9b-36d6de9e3879.png?raw=true"
                },
                neuro: { 
                    title: "/neuro/ - Conciencia Cibernética", 
                    description: "Temas: Aumento Neural, Tecnología Cyberpunk, Interfaces Mente-Máquina", 
                    footer: "La carne es débil. La máquina está dispuesta. La mente es eterna.",
                    coverImage: "https://raw.githubusercontent.com/YanYuary/NEUROCIRCUITOSCONCIENCIACOSMICA/main/8b0b6796-da1d-4852-8f5a-596410e901e2.png?raw=true"
                },
                energia: { 
                    title: "/energía/ - Exploración Lúcida y Oneironáutica", 
                    description: "Temas: Control de Sueños, Hipnagogia, Sueños Compartidos, Proyección Astral", 
                    footer: "El mundo de los sueños es tan real como el de la vigilia. Los límites son delgados.",
                    coverImage: "https://raw.githubusercontent.com/YanYuary/NEUROCIRCUITOSCONCIENCIACOSMICA/main/603b238d-2b79-4039-bb35-25f7c6d86.png?raw=true" // URL corregida
                },
                fungis: { 
                    title: "/fungis/ - Nostalgia Neon y Delirio Cyber", 
                    description: "Temas: Anime Clásico, Retro-Futurismo, Estética Cyberpunk", 
                    footer: "Fantasmas en la máquina. Recuerdos en la estática. Sueños en los datos.",
                    coverImage: "https://raw.githubusercontent.com/YanYuary/NEUROCIRCUITOSCONCIENCIACOSMICA/main/2d19befb-3cf5-4dc3-a69a-af48c19bb1b3.png?raw=true"
                },
                tarot: { 
                    title: "/tarot/ - Arcanos y Sincronicidad", 
                    description: "Temas: Lecturas de Tarot, Simbolismo Arcano, Adivinación, Conexión Espiritual", 
                    footer: "Las cartas revelan los ecos del alma y los susurros del destino.",
                    coverImage: "https://raw.githubusercontent.com/YanYuary/NEUROCIRCUITOSCONCIENCIACOSMICA/main/533a0312-1dad-4240-a231-2efbde031db2.png?raw=true"
                },
                lucidum: {
                    title: "/lucidum/ - Conciencia Lúcida",
                    description: "Explora la lucidez y los estados alterados de conciencia.",
                    footer: "Despierta en el sueño, despierta en la realidad.",
                    coverImage: "https://raw.githubusercontent.com/YanYuary/NEUROCIRCUITOSCONCIENCIACOSMICA/main/lucidum_cover.png?raw=true"
                },
                matrix: {
                    title: "/matrix/ - Realidad y Simulación",
                    description: "Cuestiona la naturaleza de la realidad y las simulaciones.",
                    footer: "La píldora roja o la píldora azul.",
                    coverImage: "https://raw.githubusercontent.com/YanYuary/NEUROCIRCUITOSCONCIENCIACOSMICA/main/matrix_cover.png?raw=true"
                },
                guerra: {
                    title: "/guerra/ - Conflictos Internos y Externos",
                    description: "Debate sobre la guerra de la conciencia y los conflictos del ego.",
                    footer: "La batalla más grande es la que se libra dentro.",
                    coverImage: "https://raw.githubusercontent.com/YanYuary/NEUROCIRCUITOSCONCIENCIACOSMICA/main/guerra_cover.png?raw=true"
                }
            };
            
            // Datos de las cartas del Tarot
            const tarotDeckData = [
                { cartnumber: 0, namecart: "The Fool", significado1cart: "Inicio, potencial ilimitado, fe en el camino", significado2cart: "Circuit 1 – Biosupervivencia: seguridad, confiar en la vida", significado3cart: "Visualiza una luz cálida en tu ombligo mientras contemplas la carta y respira profundo.", urlcart: "https://video-genesis.com/NFT/wp-content/uploads/2023/11/0foolStrength-BOTAtarot.jpg" },
                { cartnumber: 1, namecart: "The Magician", significado1cart: "Voluntad consciente, capacidad de manifestar", significado2cart: "Circuit 2 – Emocional/Territorial: energía, poder personal", significado3cart: "Siente cómo la emoción que evoca la imagen sube por tu plexo y afírmala con un gesto.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2020/08/1.BOTA_Tarot_The-Magician.jpg" },
                { cartnumber: 2, namecart: "High Priestess", significado1cart: "Intuición, misterios velados, sabiduría interna", significado2cart: "Circuit 3 – Simbólico/Racional: lenguaje y lógica", significado3cart: "Toma la carta, escribe tres símbolos o palabras que surgen y observa sus conexiones.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2020/08/2.BOTA_Tarot_The-High-Priestess.jpg" },
                { cartnumber: 3, namecart: "The Empress", significado1cart: "Creatividad, fertilidad, abundancia", significado2cart: "Circuit 4 – Socio‑sexual: pertenencia e identidad", significado3cart: "Comparte tu interpretación con alguien cercano y observa la resonancia mutua.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2020/08/3.BOTA_Tarot_The-Empress.jpg" },
                { cartnumber: 4, namecart: "The Emperor", significado1cart: "Estructura, autoridad, disciplina", significado2cart: "Circuit 5 – Neuro‑somático: éxtasis corporal, bienestar", significado3cart: "Haz respiración consciente moviendo el cuerpo con la imagen presente ante ti.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/4-bota_tarot_the-emperor.jpg" },
                { cartnumber: 5, namecart: "The Hierophant", significado1cart: "Tradición, guía espiritual, aprendizaje", significado2cart: "Circuit 6 – Neuro‑eléctrico: intuición, visión holística", significado3cart: "Medita 10 minutos con la carta frente al entrecejo, dejando llegar flashes intuitivos.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2020/08/5.BOTA_Tarot_The-Hierophant.jpg" },
                { cartnumber: 6, namecart: "TThe Lovers", significado1cart: "Integración de opuestos, elección consciente", significado2cart: "Circuit 7 – Neuro‑genético: consciencia arquetípica", significado3cart: "Antes de dormir, coloca la carta bajo la almohada y anota sueños al despertar.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2020/08/6.BOTA_Tarot_The-Lovers.jpg" },
                { cartnumber: 7, namecart: "The Chariot", significado1cart: "Dominio de fuerzas, autodirección", significado2cart: "Circuit 8 – Cuántico‑noético: trascendencia, unidad", significado3cart: "Realiza una sesión de meditación profunda (theta) sosteniendo la carta en la mano.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/7-bota_tarot_the-chariot.jpg" },
                { cartnumber: 8, namecart: "Strength", significado1cart: "Valor, autocontrol emocional, compasión", significado2cart: "Circuit 1 – Biosupervivencia: seguridad, confiar en la vida", significado3cart: "Visualiza una luz cálida en tu ombligo mientras contemplas la carta y respira profundo.", urlcart: "https://video-genesis.com/NFT/wp-content/uploads/2023/11/0foolStrength-BOTAtarot.jpg" },
                { cartnumber: 9, namecart: "The Hermit", significado1cart: "Búsqueda interior, introspección, retiro", significado2cart: "Circuit 2 – Emocional/Territorial: energía, poder personal", significado3cart: "Siente cómo la emoción que evoca la imagen sube por tu plexo y afírmala con un gesto.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/9-bota_tarot_the-hermit.jpg" },
                { cartnumber: 10, namecart: "Wheel of Fortune", significado1cart: "Cambio cíclico, destino, oportunidad", significado2cart: "Circuit 3 – Simbólico/Racional: lenguaje y lógica", significado3cart: "Toma la carta, escribe tres símbolos o palabras que surgen y observa sus conexiones.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/10-bota_tarot_wheel-of-fortune.jpg" },
                { cartnumber: 11, namecart: "Justice", significado1cart: "Equilibrio, causa‑efecto, verdad", significado2cart: "Circuit 4 – Socio‑sexual: pertenencia e identidad", significado3cart: "Comparte tu interpretación con alguien cercano y observa la resonancia mutua.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/11-bota_tarot_justice.jpg" },
                { cartnumber: 12, namecart: "The Hanged Man", significado1cart: "Entrega, nueva perspectiva, sacrificio", significado2cart: "Circuit 5 – Neuro‑somático: éxtasis corporal, bienestar", significado3cart: "Haz respiración consciente moviendo el cuerpo con la imagen presente ante ti.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/12-bota_tarot_the-hanged-man.jpg" },
                { cartnumber: 13, namecart: "Death", significado1cart: "Transformación radical, fin y renacimiento", significado2cart: "Circuit 6 – Neuro‑eléctrico: intuición, visión holística", significado3cart: "Medita 10 minutos con la carta frente al entrecejo, dejando llegar flashes intuitivos.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/13-bota_tarot_death.jpg" },
                { cartnumber: 14, namecart: "Temperance", significado1cart: "Alquimia interna, moderación, armonía", significado2cart: "Circuit 7 – Neuro‑genético: consciencia arquetípica", significado3cart: "Antes de dormir, coloca la carta bajo la almohada y anota sueños al despertar.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/14-bota_tarot_temperance.jpg" },
                { cartnumber: 15, namecart: "The Devil", significado1cart: "Apegos, sombra, liberación de cadenas", significado2cart: "Circuit 8 – Cuántico‑noético: trascendencia, unidad", significado3cart: "Realiza una sesión de meditación profunda (theta) sosteniendo la carta en la mano.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/15-bota_tarot_the-devil.jpg" },
                { cartnumber: 16, namecart: "The Tower", significado1cart: "Colapso de estructuras falsas, revelación", significado2cart: "Circuit 1 – Biosupervivencia: seguridad, confiar en la vida", significado3cart: "Visualiza una luz cálida en tu ombligo mientras contemplas la carta y respira profundo.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/16-bota_tarot_the-tower.jpg" },
                { cartnumber: 17, namecart: "The Star", significado1cart: "Esperanza, inspiración, fluidez", significado2cart: "Circuit 2 – Emocional/Territorial: energía, poder personal", significado3cart: "Siente cómo la emoción que evoca la imagen sube por tu plexo y afírmala con un gesto.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/17-bota_tarot_the-star.jpg" },
                { cartnumber: 18, namecart: "The Moon", significado1cart: "Inconsciente, ilusión, prueba emocional", significado2cart: "Circuit 3 – Simbólico/Racional: lenguaje y lógica", significado3cart: "Toma la carta, escribe tres símbolos o palabras que surgen y observa sus conexiones.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/18-bota_tarot_the-moon.jpg" },
                { cartnumber: 19, namecart: "The Sun", significado1cart: "Claridad, vitalidad, realización", significado2cart: "Circuit 4 – Socio‑sexual: pertenencia e identidad", significado3cart: "Comparte tu interpretación con alguien cercano y observa la resonancia mutua.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/19-bota_tarot_the-sun.jpg" },
                { cartnumber: 20, namecart: "Judgement", significado1cart: "Llamado superior, resurrección, integración", significado2cart: "Circuit 5 – Neuro‑somático: éxtasis corporal, bienestar", significado3cart: "Haz respiración consciente moviendo el cuerpo con la imagen presente ante ti.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/20-bota_tarot_judgement.jpg" },
                { cartnumber: 21, namecart: "The World", significado1cart: "Plenitud, cierre de ciclo, maestría", significado2cart: "Circuit 6 – Neuro‑eléctrico: intuición, visión holística", significado3cart: "Medita 10 minutos con la carta frente al entrecejo, dejando llegar flashes intuitivos.", urlcart: "https://www.esotericmeanings.com/wp-content/uploads/2016/07/21-bota_tarot_the-world.jpg" }
            ];

            let unsubscribePosts = null; 

            // Función que se ejecuta cuando el DOM está completamente cargado
            document.addEventListener('DOMContentLoaded', function() {
                setupEventListeners(); 
                setupProfileEmojiPicker(); 
                applyInitialTheme(); 
                if (state.isAdmin) setupAdminPanel(); 
                document.getElementById('currentYear').textContent = new Date().getFullYear(); 

                state.currentPostAvatar = localStorage.getItem('neurochan_profile_avatar') || AVATARS[Math.floor(Math.random() * AVATARS.length)];
                document.getElementById('mainPostAvatar').textContent = state.currentPostAvatar;

                onAuthStateChanged(auth, (user) => {
                    if (user) { 
                        handleHashChange(); 
                    } else {
                        signInAnonymously(auth).catch((error) => {
                            let userMessage = 'Error de conexión. Intenta recargar.';
                            const loadingMessageElement = document.getElementById('loadingMessage');

                            if (loadingMessageElement) {
                                loadingMessageElement.classList.remove('hidden'); 
                                if (error.code === 'auth/configuration-not-found') {
                                     userMessage = 'ERROR DE CONFIGURACIÓN DE FIREBASE: El inicio de sesión anónimo no está habilitado. Por favor, ve a tu consola de Firebase -> Authentication -> Sign-in method y habilita el proveedor "Anónimo".';
                                    console.error("ACCIÓN REQUERIDA: Habilita el proveedor de inicio de sesión 'Anónimo' en la sección 'Authentication' -> 'Sign-in method' de tu Firebase console.");
                                }
                                loadingMessageElement.textContent = userMessage;
                            }
                        });
                    }
                });
                window.addEventListener('hashchange', handleHashChange); 

                // Listeners para el Tarot (asegurando que se añaden una vez)
                const deckCard = document.getElementById('tarotDeckCard');
                const shuffleBtn = document.getElementById('shuffleTarotButton');
                if (deckCard && !deckCard.dataset.listenerAdded) {
                    deckCard.addEventListener('click', shuffleAndDealTarot);
                    deckCard.dataset.listenerAdded = "true";
                }
                if (shuffleBtn && !shuffleBtn.dataset.listenerAdded) {
                    shuffleBtn.addEventListener('click', shuffleAndDealTarot);
                    shuffleBtn.dataset.listenerAdded = "true";
                }
                 // Listener para el botón de configuración global (asegurando que se añade una vez)
                const settingsButton = document.getElementById('settingsToggle');
                if (settingsButton && !settingsButton.dataset.listenerAdded) {
                    settingsButton.addEventListener('click', openSettingsModal);
                    settingsButton.dataset.listenerAdded = 'true';
                }
            });

            function showAdminLoginInSettings() {
                document.getElementById('adminLoginModalButton').style.display = 'none';
                document.getElementById('adminLogoutFromSettingsButton').style.display = 'none'; 
                document.getElementById('adminPasswordInputAreaSettings').style.display = 'block';
                document.getElementById('adminPasswordSettingsInput').focus();
            }

            function hideAdminLoginInSettings() {
                document.getElementById('adminPasswordInputAreaSettings').style.display = 'none';
                document.getElementById('adminPasswordSettingsInput').value = '';
                if (state.isAdmin) {
                    document.getElementById('adminLoginModalButton').style.display = 'none';
                    document.getElementById('adminLogoutFromSettingsButton').style.display = 'block';
                } else {
                    document.getElementById('adminLoginModalButton').style.display = 'block';
                    document.getElementById('adminLogoutFromSettingsButton').style.display = 'none';
                }
            }

            function handleAdminLogoutFromSettings() {
                adminLogout(); 
                document.getElementById('adminLoginModalButton').style.display = 'block';
                document.getElementById('adminLogoutFromSettingsButton').style.display = 'none';
                closeSettingsModal(); 
            }

            function verifyAdminPasswordFromSettings() { 
                const password = document.getElementById('adminPasswordSettingsInput').value; 
                if (bcryptInstance && bcryptInstance.compareSync(password, ADMIN_HASH)) {
                    state.isAdmin = true;
                    localStorage.setItem('neurochan_admin', 'true');
                    closeSettingsModal();
                    setupAdminPanel();
                    showGenericModal("Acceso Concedido", "Has iniciado sesión como administrador.", [{ text: 'OK', action: closeGenericModal }]);
                    loadContentForBoard(); 
                } else {
                    showGenericModal("Acceso Denegado", "La contraseña de administrador es incorrecta.", [{ text: 'Intentar de Nuevo', action: () => { document.getElementById('adminPasswordSettingsInput').focus(); document.getElementById('adminPasswordSettingsInput').value = ''; } }, { text: 'Cancelar', action: closeGenericModal }]);
                }
            }

            function applyInitialTheme() {
                if (localStorage.getItem('neurochan_theme') === 'dark') {
                    document.body.classList.add('dark-theme');
                    document.getElementById('themeColorMeta').setAttribute('content', getComputedStyle(document.documentElement).getPropertyValue('--dark-app-bg').trim());
                } else {
                    document.body.classList.remove('dark-theme'); 
                    document.getElementById('themeColorMeta').setAttribute('content', getComputedStyle(document.documentElement).getPropertyValue('--app-bg').trim());
                }
                updateThemeButtonText(); 
            }
            
            function handleHashChange() {
                const hash = window.location.hash.substring(1); 
                const params = new URLSearchParams(hash);
                const postIdFromUrl = params.get('post');
                const boardFromUrl = params.get('board') || state.currentBoard;

                let boardActuallyChanged = false;
                if (boardFromUrl && boardFromUrl !== state.currentBoard) {
                    state.currentBoard = boardFromUrl; 
                    boardActuallyChanged = true;
                    document.querySelectorAll('.board-selector').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.board === state.currentBoard);
                    });
                }
                
                const previousViewingThreadId = state.viewingThreadId;
                state.viewingThreadId = postIdFromUrl || null;
                
                document.getElementById('postsContainer').innerHTML = '';
                document.getElementById('threadContainer').innerHTML = '';

                if (boardActuallyChanged || state.viewingThreadId !== previousViewingThreadId || !unsubscribePosts || (boardFromUrl && boardFromUrl !== 'tarot') || (boardFromUrl === 'tarot' && state.currentBoard === 'tarot') ) {
                    loadContentForBoard(); // CORREGIDO: Se llama a loadContentForBoard que decide si cargar posts o tarot
                }
                updateUiForView(); 
                updateBoardCoverDisplay(); 

                if (state.viewingThreadId && postIdFromUrl && postIdFromUrl === state.viewingThreadId) {
                    setTimeout(() => {
                        const opPostElement = document.querySelector(`#post-${state.viewingThreadId}`);
                        if (opPostElement) {
                            // No es necesario mostrar el formulario de respuesta aquí, solo al hacer clic en "Responder"
                        }
                        if (state.scrollAfterReply) {
                            const targetElement = document.getElementById(`post-${state.scrollAfterReply}`);
                            if (targetElement) {
                                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                            state.scrollAfterReply = null;
                        }
                    }, 300); 
                }
            }

            function loadContentForBoard() {
                if (state.currentBoard === 'tarot') {
                    setupTarotGame(); 
                } else {
                    loadAndRenderPostsRealtime(); 
                }
            }

            function setupEventListeners() {
                document.getElementById('submitPost').addEventListener('click', createPost); 
                document.getElementById('adminLogoutButton').addEventListener('click', adminLogout); 
                setupAudioToggle(); 
                setupFileUpload(); 
                document.getElementById('boardCoverUploadInput').addEventListener('change', uploadBoardCover); 
                document.getElementById('selectExistingCoverButton').addEventListener('click', openSelectCoverModal); 

                document.querySelectorAll('.board-selector').forEach(btn => {
                    btn.addEventListener('click', function() {
                        changeBoard(btn.dataset.board);
                    });
                });

                document.getElementById('cancelDelete').addEventListener('click', closeDeleteModal);
                document.getElementById('confirmDelete').addEventListener('click', deletePostWithPassword);
                
                document.getElementById('infoToggle').addEventListener('click', openInfoModal);
                document.getElementById('closeInfoModal').addEventListener('click', closeInfoModal);
                
                document.getElementById('confirmEdit').addEventListener('click', () => confirmEdit()); 
                document.getElementById('cancelEdit').addEventListener('click', closeEditModal);

                // Los listeners para settingsToggle y tarot se mueven a DOMContentLoaded para asegurar que los elementos existan
                // document.getElementById('settingsToggle').addEventListener('click', openSettingsModal); // Movido
                document.getElementById('closeSettingsModal').addEventListener('click', closeSettingsModal);
                document.getElementById('themeToggleModalButton').addEventListener('click', toggleTheme);
                document.getElementById('adminLoginModalButton').addEventListener('click', showAdminLoginInSettings);
                document.getElementById('adminLogoutFromSettingsButton').addEventListener('click', handleAdminLogoutFromSettings);
                document.getElementById('confirmAdminLoginSettings').addEventListener('click', verifyAdminPasswordFromSettings);
                document.getElementById('cancelAdminLoginSettings').addEventListener('click', hideAdminLoginInSettings);
                
                // document.getElementById('shuffleTarotButton').addEventListener('click', shuffleAndDealTarot); // Movido

                document.getElementById('postPasswordToggle').addEventListener('click', () => openPostPasswordModal(false));
                document.getElementById('closePostPasswordModal').addEventListener('click', closePostPasswordModal);
                document.getElementById('cancelPostPassword').addEventListener('click', cancelPostPassword);
                document.getElementById('confirmPostPassword').addEventListener('click', confirmPostPassword);

                document.getElementById('mainPostAvatar').addEventListener('click', () => openProfileEmojiPicker(document.getElementById('mainPostAvatar')));

                document.getElementById('postContent').addEventListener('input', autoResizeTextarea);

                document.getElementById('searchToggle').addEventListener('click', toggleSearchInput);
                document.getElementById('postSearchInput').addEventListener('input', filterPosts);
                document.getElementById('postSearchInput').addEventListener('blur', (e) => {
                    if (e.target.value.trim() === '') {
                        document.querySelector('.search-input-container').classList.remove('active');
                    }
                });
                document.getElementById('randomPostButton').addEventListener('click', viewRandomPost);

                document.getElementById('closeImageViewerModal').addEventListener('click', closeImageViewerModal);
                document.getElementById('downloadImageButton').addEventListener('click', downloadEnlargedImage);
                document.getElementById('imageViewerModal').addEventListener('click', (e) => {
                    if (e.target === document.getElementById('imageViewerModal')) {
                        closeImageViewerModal();
                    }
                });

                document.getElementById('postsContainer').addEventListener('click', handlePostContainerClick);
                document.getElementById('threadContainer').addEventListener('click', handlePostContainerClick);

                document.getElementById('closeSelectCoverModal').addEventListener('click', closeSelectCoverModal);
                document.getElementById('cancelSelectCover').addEventListener('click', closeSelectCoverModal);
                document.getElementById('cancelDeleteCover').addEventListener('click', closeConfirmDeleteCoverModal);
                document.getElementById('confirmDeleteCover').addEventListener('click', deleteSelectedCover);

                document.getElementById('neuroChanTitle').addEventListener('click', (e) => {
                    e.preventDefault(); 
                    window.location.hash = `board=social`; 
                });
            }

            function handlePostContainerClick(event) {
                const target = event.target;
                const postElement = target.closest('.post');
                const postId = postElement?.dataset.id; 
                if (!postId) return; 

                if (target.closest('.heart-reaction-button')) {
                    reaccionarCorazon(postId);
                } else if (target.closest('.funny-reaction-button')) {
                    reaccionarMeDiverte(postId);
                } else if (target.closest('.angry-reaction-button')) {
                    reaccionarMeEnoja(postId);
                } 
                else if (target.closest('.reply-button')) {
                    replyToPost(postId);
                } 
                else if (target.closest('.delete-button')) {
                    const post = state.allPostsData[postId];
                    if (post) {
                        if (state.isAdmin) deletePostFirestore(postId);
                        else openDeleteModal(postId, post.passwordHash);
                    }
                } 
                else if (target.closest('.edit-button')) {
                    openEditModal(postId);
                } 
                else if (target.closest('.comments-button')) {
                    toggleRepliesVisibility(postId, postElement);
                } 
                else if (target.closest('.post-image-container img')) {
                    openImageViewerModal(postId);
                } 
                else if (target.closest('.post-title-link')) {
                    event.preventDefault(); 
                    viewThread(postId);
                } 
                else if (target.closest('.reply-link')) {
                    event.preventDefault();
                    const referencedPostId = target.closest('.reply-link').dataset.postId;
                    const fullReferencedPost = state.allPostsData[referencedPostId];
                    if (fullReferencedPost) {
                        const threadRootId = fullReferencedPost.replyTo || referencedPostId;
                        state.scrollAfterReply = referencedPostId; 
                        window.location.hash = `board=${fullReferencedPost.board}&post=${threadRootId}`;
                    } else {
                        showGenericModal("Post no encontrado", "El post al que se hace referencia no pudo ser localizado.", [{ text: 'OK', action: closeGenericModal }]);
                    }
                }
                else if (target.closest('.post-username')) {
                    event.preventDefault();
                    viewThread(postId);
                }
            }

            function setupProfileEmojiPicker() {
                const profileEmojiGrid = document.getElementById('profileEmojiGrid');
                const profileEmojiPickerModal = document.getElementById('profileEmojiPickerModal');
                const closeProfileEmojiPickerModal = document.getElementById('closeProfileEmojiPickerModal');

                AVATARS.forEach(emoji => { 
                    const emojiBtn = document.createElement('button');
                    emojiBtn.className = 'emoji-option';
                    emojiBtn.textContent = emoji;
                    emojiBtn.addEventListener('click', function() {
                        if (state.profileEmojiPickerTarget) {
                            state.profileEmojiPickerTarget.textContent = emoji;
                            if (state.profileEmojiPickerTarget.id === 'mainPostAvatar') {
                                state.currentPostAvatar = emoji;
                                localStorage.setItem('neurochan_profile_avatar', emoji);
                            } else {
                                const replyAvatarElement = state.profileEmojiPickerTarget;
                                if (replyAvatarElement.classList.contains('reply-avatar')) {
                                    replyAvatarElement.dataset.avatar = emoji;
                                }
                            }
                        }
                        profileEmojiPickerModal.classList.remove('flex');
                        document.body.classList.remove('modal-open'); 
                    });
                    profileEmojiGrid.appendChild(emojiBtn);
                });

                closeProfileEmojiPickerModal.addEventListener('click', () => {
                    profileEmojiPickerModal.classList.remove('flex');
                    document.body.classList.remove('modal-open'); 
                    state.profileEmojiPickerTarget = null;
                });

                profileEmojiPickerModal.addEventListener('click', (e) => {
                    if (e.target === profileEmojiPickerModal) {
                        profileEmojiPickerModal.classList.remove('flex');
                        document.body.classList.remove('modal-open'); 
                        state.profileEmojiPickerTarget = null;
                    }
                });
            }

            function openProfileEmojiPicker(targetElement) {
                state.profileEmojiPickerTarget = targetElement;
                document.getElementById('profileEmojiPickerModal').classList.add('flex');
                document.body.classList.add('modal-open'); 
            }

            function insertAtCursor(textarea, text) {
                const startPos = textarea.selectionStart;
                const endPos = textarea.selectionEnd;
                const currentText = textarea.value;
                textarea.value = currentText.substring(0, startPos) + text + currentText.substring(endPos);
                textarea.selectionStart = textarea.selectionEnd = startPos + text.length;
                textarea.focus();
            }

            function autoResizeTextarea(event) {
                const textarea = event.target;
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
            }

            async function createPost() {
                const contentInput = document.getElementById('postContent').value.trim();
                const name = state.tempPostName || "Anónimo";
                const title = state.tempPostTitle || null; 
                const password = state.tempPostPassword; 
                const fileInput = document.getElementById('fileUpload');

                if (!auth.currentUser) {
                    showGenericModal("Error de Autenticación", "No estás conectado. Por favor, recarga la página para intentar de nuevo.", [{ text: 'Entendido', action: closeGenericModal }]);
                    console.error("Intento de crear post sin usuario autenticado.");
                    return;
                }

                if (!contentInput && !fileInput.files[0]) {
                    showGenericModal("Atención", "El contenido del post no puede estar vacío si no adjuntas una imagen.", [{ text: 'Entendido', action: closeGenericModal }]);
                    return;
                }

                let actualReplyTo = null;
                if (state.viewingThreadId) { 
                    const opPost = state.allPostsData[state.viewingThreadId];
                    actualReplyTo = opPost.replyTo || state.viewingThreadId;
                } 

                const newPostData = {
                    authorUID: auth.currentUser.uid, 
                    avatar: state.currentPostAvatar, 
                    board: state.currentBoard,
                    text: DOMPurify.sanitize(contentInput), 
                    title: title ? DOMPurify.sanitize(title) : null, 
                    image: null,
                    name: DOMPurify.sanitize(name), 
                    passwordHash: password && bcryptInstance ? bcryptInstance.hashSync(password, 10) : null,
                    heartCount: 0,
                    funnyCount: 0,
                    angryCount: 0,
                    reactedBy: {}, 
                    timestamp: serverTimestamp(), 
                    replyTo: actualReplyTo, 
                };
                
                const submitButton = document.getElementById('submitPost');
                submitButton.disabled = true;
                submitButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 animate-spin" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L9 11.414V15a1 1 0 102 0v-3.586l1.293-1.293a1 1 0 000-1.414z" clip-rule="evenodd" /></svg>`;

                try {
                    if (fileInput.files[0]) {
                        const file = fileInput.files[0];
                        if (file.size > MAX_IMAGE_SIZE) {
                            showGenericModal("Error de Archivo", "La imagen es demasiado grande. El tamaño máximo permitido es 4MB.", [{ text: 'Entendido', action: closeGenericModal }]);
                            submitButton.disabled = false;
                            submitButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 16.571V11a1 1 0 112 0v5.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>`;
                            return;
                        }
                        const reader = new FileReader();
                        reader.onload = async function(e) {
                            compressImage(e.target.result, async function(compressedImage) {
                                newPostData.image = compressedImage;
                                await completePostCreationFirestore(newPostData);
                            });
                        };
                        reader.readAsDataURL(file);
                    } else { 
                        await completePostCreationFirestore(newPostData);
                    }
                } catch (error) {
                    console.error("Error creando post:", error);
                    showGenericModal("Error", "Ocurrió un error al enviar el post. Por favor, inténtalo de nuevo.", [{ text: 'OK', action: closeGenericModal }]);
                    submitButton.disabled = false;
                    submitButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 16.571V11a1 1 0 112 0v5.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>`;
                }
            }
            
            async function completePostCreationFirestore(postData) {
                try {
                    const docRef = await addDoc(postsCollectionRef, postData);
                    console.log("Post creado con ID: ", docRef.id);
                    
                    document.getElementById('postContent').value = '';
                    document.getElementById('fileUpload').value = '';
                    document.getElementById('fileName').textContent = '';
                    
                    state.tempPostPassword = null; 
                    state.tempPostName = null;    
                    state.tempPostTitle = null; 
                    state.replyTo = null; 
                    
                    state.currentPostAvatar = localStorage.getItem('neurochan_profile_avatar') || AVATARS[Math.floor(Math.random() * AVATARS.length)];
                    document.getElementById('mainPostAvatar').textContent = state.currentPostAvatar;

                    const postContentTextarea = document.getElementById('postContent');
                    postContentTextarea.style.height = 'auto';
                    postContentTextarea.style.height = postContentTextarea.scrollHeight + 'px';

                    document.getElementById('postContent').placeholder = "¿Qué estás pensando...?";

                } catch (error) {
                    console.error("Error guardando post en Firestore:", error);
                    showGenericModal("Error de Guardado", "No se pudo guardar el post en la base de datos. Intenta de nuevo.", [{ text: 'OK', action: closeGenericModal }]);
                } finally {
                    const submitButton = document.getElementById('submitPost');
                    submitButton.disabled = false;
                    submitButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 16.571V11a1 1 0 112 0v5.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>`;
                }
            }

            function compressImage(imageData, callback) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const maxWidth = 1024; const maxHeight = 1024; // Aumentado ligeramente para mejor calidad
                    let width = img.width; let height = img.height;
                    if (width > height) { if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; } } 
                    else { if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; } }
                    canvas.width = width; canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.85); // Calidad ligeramente aumentada
                    callback(compressedDataUrl);
                };
                img.onerror = function() {
                    console.error("Error al cargar imagen para compresión.");
                    callback(null); // Devolver null si hay error
                };
                img.src = imageData;
            }
            
            function updateUiForView() {
                const postsContainer = document.getElementById('postsContainer');
                const threadContainer = document.getElementById('threadContainer');
                const postFormContainer = document.getElementById('postFormContainer');
                const boardInfoSection = document.getElementById('boardInfo');
                const tarotGameContainer = document.getElementById('tarotGameContainer');
                const mainPostContentTextarea = document.getElementById('postContent');
                const searchToggle = document.getElementById('searchToggle');
                const searchInputContainer = document.querySelector('.search-input-container');
                const randomPostButton = document.getElementById('randomPostButton');
                const storiesContainer = document.getElementById('storiesContainer');


                if (state.currentBoard === 'tarot') {
                    postsContainer.classList.add('hidden');
                    threadContainer.classList.add('hidden');
                    if (postFormContainer) postFormContainer.classList.add('hidden');
                    if (boardInfoSection) boardInfoSection.classList.remove('hidden'); 
                    if (searchToggle) searchToggle.style.display = 'none';
                    if (searchInputContainer) searchInputContainer.classList.remove('active');
                    if (randomPostButton) randomPostButton.style.display = 'none';
                    if (storiesContainer) storiesContainer.classList.add('hidden');
                    tarotGameContainer.classList.remove('hidden');
                    tarotGameContainer.classList.add('flex'); // Asegurar que sea flex para centrar
                } else if (state.viewingThreadId) {
                    postsContainer.classList.add('hidden');
                    threadContainer.classList.remove('hidden');
                    if (postFormContainer) postFormContainer.classList.add('hidden');
                    if (boardInfoSection) boardInfoSection.classList.add('hidden');
                    if (searchToggle) searchToggle.style.display = 'none';
                    if (searchInputContainer) searchInputContainer.classList.remove('active');
                    if (randomPostButton) randomPostButton.style.display = 'none';
                    if (storiesContainer) storiesContainer.classList.add('hidden');
                    tarotGameContainer.classList.add('hidden');
                    tarotGameContainer.classList.remove('flex');
                } else {
                    postsContainer.classList.remove('hidden');
                    threadContainer.classList.add('hidden');
                    threadContainer.innerHTML = ''; 
                    document.querySelectorAll('.reply-form-container').forEach(form => hideReplyForm(form));
                    document.querySelectorAll('.replies-container').forEach(container => container.style.display = 'none'); 

                    if (postFormContainer) postFormContainer.classList.remove('hidden');
                    if (boardInfoSection) boardInfoSection.classList.remove('hidden');
                    if (searchToggle) searchToggle.style.display = 'inline-flex';
                    if (randomPostButton) randomPostButton.style.display = 'inline-flex';
                    if (storiesContainer) storiesContainer.classList.remove('hidden');
                    tarotGameContainer.classList.add('hidden');
                    tarotGameContainer.classList.remove('flex');
                    mainPostContentTextarea.placeholder = "¿Qué estás pensando...?";
                }
            }

            function populateDirectCounts(allPosts, tempRepliesByParent) {
                state.directChildrenCounts = {}; 
                function countDescendantsRecursive(postId) {
                    let count = 0;
                    const directReplies = tempRepliesByParent[postId] || [];
                    count += directReplies.length;
                    for (const reply of directReplies) {
                        count += countDescendantsRecursive(reply.id);
                    }
                    return count;
                }

                allPosts.forEach(p => {
                    state.directChildrenCounts[p.id] = countDescendantsRecursive(p.id);
                });
            }

            function loadAndRenderPostsRealtime() {
                const loadingMessage = document.getElementById('loadingMessage');
                if (loadingMessage) {
                    loadingMessage.classList.remove('hidden');
                    loadingMessage.textContent = 'Cargando transmisiones...'; 
                }

                if (unsubscribePosts) {
                    unsubscribePosts(); 
                    unsubscribePosts = null; 
                }

                if (!auth.currentUser) {
                    if (loadingMessage) {
                        loadingMessage.textContent = 'Esperando conexión segura...';
                         loadingMessage.classList.remove('hidden');
                    }
                    return;
                }
                
                updateUiForView(); 

                let boardsToQuery = [state.currentBoard];
                const legacyBoardName = Object.keys(BOARD_MIGRATION).find(key => BOARD_MIGRATION[key] === state.currentBoard);
                if (legacyBoardName && legacyBoardName !== state.currentBoard) {
                     boardsToQuery.push(legacyBoardName);
                }


                const postsCollectionQuery = query(postsCollectionRef, where("board","in", boardsToQuery));

                unsubscribePosts = onSnapshot(postsCollectionQuery, (querySnapshot) => {
                    state.allPostsData = {}; 
                    let ops = []; 
                    querySnapshot.forEach(docSnap => {
                        const postData = { id: docSnap.id, ...docSnap.data() };
                        state.allPostsData[postData.id] = postData;
                        if (!postData.replyTo) { 
                            ops.push(postData);
                        }
                    });

                    const tempRepliesByParentForCounts = {};
                    Object.values(state.allPostsData).forEach(p => {
                        if (p.replyTo) {
                            if (!tempRepliesByParentForCounts[p.replyTo]) tempRepliesByParentForCounts[p.replyTo] = [];
                            tempRepliesByParentForCounts[p.replyTo].push(p);
                        }
                    });

                    populateDirectCounts(Object.values(state.allPostsData), tempRepliesByParentForCounts);

                    ops.sort((a, b) => {
                        const timeA = a.timestamp?.toDate ? a.timestamp.toDate().getTime() : (a.timestamp ? new Date(a.timestamp).getTime() : 0);
                        const timeB = b.timestamp?.toDate ? b.timestamp.toDate().getTime() : (b.timestamp ? new Date(b.timestamp).getTime() : 0);
                        return timeB - timeA;
                    });

                    state.allRootPosts = [...ops]; 

                    if (state.viewingThreadId) {
                        const threadContainer = document.getElementById('threadContainer');
                        threadContainer.innerHTML = ''; 

                        const opPostData = state.allPostsData[state.viewingThreadId];
                        if (opPostData) {
                            const totalCount = state.directChildrenCounts[opPostData.id] || 0;
                            const opElement = createPostElement(opPostData, true, totalCount, 0);
                            threadContainer.appendChild(opElement);
                            applyPostEffects(opPostData, opElement);
                            loadNestedReplies(opPostData.id, opElement, 1);
                        } else {
                            threadContainer.innerHTML = '<p class="text-center text-red-400">Este post no existe o fue eliminado.</p>';
                        }
                    } else {
                        renderFilteredPosts(ops); 
                        renderStories(); 
                    }

                    if (loadingMessage) loadingMessage.classList.add('hidden');
                }, (error) => {
                    console.error("Error obteniendo posts del tablero:", error);
                    if (loadingMessage) {
                        loadingMessage.textContent = 'Error al cargar posts. Revisa la consola.';
                        loadingMessage.classList.remove('hidden');
                    }
                });
            }

            function renderFilteredPosts(postsToRender) {
                const postsContainer = document.getElementById('postsContainer');
                const currentOpElements = new Map();
                Array.from(postsContainer.children).forEach(child => {
                    if (child.dataset.id) {
                        currentOpElements.set(child.dataset.id, child);
                    }
                });

                const newOpIds = new Set(postsToRender.map(op => op.id));

                for (const [postId, element] of currentOpElements) {
                    if (!newOpIds.has(postId)) {
                        element.remove();
                        currentOpElements.delete(postId);
                    }
                }

                const fragment = document.createDocumentFragment(); 
                postsToRender.forEach(opData => {
                    let opElement = currentOpElements.get(opData.id);
                    const totalCount = state.directChildrenCounts[opData.id] || 0;

                    if (opElement) {
                        updatePostElement(opElement, opData, 0); 
                    } else {
                        opElement = createPostElement(opData, false, totalCount, 0); 
                        applyPostEffects(opData, opElement);
                        currentOpElements.set(opData.id, opElement);
                    }
                    fragment.appendChild(opElement);
                });
                
                postsContainer.innerHTML = ''; 
                postsContainer.appendChild(fragment);

                if (postsToRender.length === 0 && document.getElementById('postSearchInput').value.trim() !== '') {
                    postsContainer.innerHTML = '<p class="text-center col-span-full text-secondary-color">No hay transmisiones que coincidan con tu búsqueda.</p>';
                } else if (postsToRender.length === 0) {
                     postsContainer.innerHTML = '<p class="text-center col-span-full text-secondary-color">Aún no hay transmisiones en este tablero. ¡Sé el primero!</p>';
                }
            }

            function filterPosts() {
                const searchTerm = document.getElementById('postSearchInput').value.toLowerCase();
                if (searchTerm === '') {
                    renderFilteredPosts(state.allRootPosts);
                    return;
                }

                const filteredPosts = state.allRootPosts.filter(post => {
                    const title = post.title ? post.title.toLowerCase() : '';
                    const text = post.text ? post.text.toLowerCase() : '';
                    const name = post.name ? post.name.toLowerCase() : '';
                    return title.includes(searchTerm) || text.includes(searchTerm) || name.includes(searchTerm);
                });
                renderFilteredPosts(filteredPosts);
            }

            function viewRandomPost() {
                if (state.allRootPosts.length > 0) {
                    const randomIndex = Math.floor(Math.random() * state.allRootPosts.length);
                    const randomPost = state.allRootPosts[randomIndex];
                    viewThread(randomPost.id);
                } else {
                    showGenericModal("Sin Posts", "No hay posts disponibles para mostrar uno aleatorio.", [{ text: 'OK', action: closeGenericModal }]);
                }
            }

            function toggleSearchInput() {
                const searchInputContainer = document.querySelector('.search-input-container');
                const searchInput = document.getElementById('postSearchInput');
                searchInputContainer.classList.toggle('active');
                if (searchInputContainer.classList.contains('active')) {
                    searchInput.focus();
                } else {
                    searchInput.value = '';
                    filterPosts(); 
                }
            }

            function formatPostTimestamp(timestamp) {
                const postDate = timestamp?.toDate ? timestamp.toDate() : (timestamp ? new Date(timestamp) : new Date());
                const today = new Date();
                
                const isToday = postDate.getDate() === today.getDate() &&
                                postDate.getMonth() === today.getMonth() &&
                                postDate.getFullYear() === today.getFullYear();

                if (isToday) {
                    return postDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                } else {
                    return postDate.toLocaleDateString('es-ES', { month: 'short', day: 'numeric' });
                }
            }

            function updatePostElement(postElement, newPostData, currentPostDepth = 0) {
                const avatarElement = postElement.querySelector('.post-avatar');
                if (avatarElement && avatarElement.textContent !== newPostData.avatar) {
                    avatarElement.textContent = newPostData.avatar;
                }

                const usernameElement = postElement.querySelector('.post-username');
                if (usernameElement && usernameElement.textContent !== DOMPurify.sanitize(newPostData.name)) {
                    usernameElement.textContent = DOMPurify.sanitize(newPostData.name);
                }

                const timestampElement = postElement.querySelector('.post-timestamp');
                if (timestampElement) {
                    const newFormattedTime = formatPostTimestamp(newPostData.timestamp);
                    const newTimestampText = `${newFormattedTime} ${newPostData.authorUID === auth.currentUser?.uid ? '<span style="color: var(--success-color);">(Tú)</span>' : ''}`;

                    if (timestampElement.innerHTML !== newTimestampText) {
                        timestampElement.innerHTML = newTimestampText;
                    }
                }

                const titleElement = postElement.querySelector('.post-title');
                if (newPostData.title) {
                    let titleLink = postElement.querySelector('.post-title-link');
                    if (titleLink) {
                        if (titleLink.textContent !== DOMPurify.sanitize(newPostData.title)) {
                            titleLink.textContent = DOMPurify.sanitize(newPostData.title);
                        }
                    } else {
                        const newTitleEl = document.createElement('h4');
                        newTitleEl.className = 'post-title';
                        newTitleEl.innerHTML = `<a href="#board=${newPostData.board}&post=${newPostData.id}" class="post-title-link">${DOMPurify.sanitize(newPostData.title)}</a>`;
                        postElement.insertBefore(newTitleEl, postElement.querySelector('.post-content') || postElement.querySelector('.post-image-container') || postElement.querySelector('.post-actions'));
                    }
                } else if (titleElement) {
                    titleElement.remove();
                }

                const contentTextElement = postElement.querySelector('.post-content');
                const postTextContent = typeof newPostData.text === 'string' ? newPostData.text : '';
                let newSanitizedText = DOMPurify.sanitize(postTextContent).replace(/\n/g,'<br>');
                
                newSanitizedText = newSanitizedText.replace(/&gt;&gt;(\w+)/g, (match, referencedPostIdSuffix) => {
                    const fullReferencedPost = Object.values(state.allPostsData).find(p => p.id.endsWith(referencedPostIdSuffix));
                    const targetPostId = fullReferencedPost ? fullReferencedPost.id : referencedPostIdSuffix;
                    const targetBoard = fullReferencedPost ? fullReferencedPost.board : state.currentBoard;
                    const threadLinkTargetId = fullReferencedPost ? (fullReferencedPost.replyTo || fullReferencedPost.id) : targetPostId;
                    return `<a href="#board=${targetBoard}&post=${threadLinkTargetId}" class="reply-link" data-post-id="${targetPostId}">>>${referencedPostIdSuffix.slice(-4)}</a>`;
                });

                if (contentTextElement) {
                    if (contentTextElement.innerHTML !== newSanitizedText) { 
                        contentTextElement.innerHTML = newSanitizedText;
                    }
                } else if (newPostData.text) {
                    const newTextEl = document.createElement('div');
                    newTextEl.className = 'post-content text-sm mb-2 mt-1';
                    newTextEl.innerHTML = newSanitizedText;
                    postElement.insertBefore(newTextEl, postElement.querySelector('.post-image-container') || postElement.querySelector('.post-actions'));
                }

                const imageContainer = postElement.querySelector('.post-image-container');
                const imageClass = state.viewingThreadId ? "max-w-full h-auto object-contain cursor-zoom-in" : "max-w-full h-auto w-full object-cover cursor-zoom-in";
                if (newPostData.image) {
                    let img = null;
                    if (imageContainer) {
                        img = imageContainer.querySelector('img');
                        if (img) {
                            if (img.src !== DOMPurify.sanitize(newPostData.image)) {
                                img.src = DOMPurify.sanitize(newPostData.image);
                            }
                            img.className = imageClass; // Asegurar clase correcta al actualizar
                        } else {
                            img = document.createElement('img');
                            img.src = DOMPurify.sanitize(newPostData.image);
                            img.alt = "Imagen del post";
                            img.className = imageClass;
                            img.loading = "lazy"; 
                            imageContainer.appendChild(img);
                        }
                    } else {
                        const newImageDiv = document.createElement('div');
                        newImageDiv.className = 'post-image-container';
                        newImageDiv.innerHTML = `<img src="${DOMPurify.sanitize(newPostData.image)}" alt="Imagen del post" class="${imageClass}" loading="lazy"/>`;
                        postElement.insertBefore(newImageDiv, postElement.querySelector('.post-actions'));
                        img = newImageDiv.querySelector('img');
                    }
                    if (img) {
                        img.onclick = () => openImageViewerModal(newPostData.id);
                    }
                } else if (imageContainer) {
                    imageContainer.remove();
                }

                const heartCountSpan = postElement.querySelector('.heart-reaction-button .count');
                if (heartCountSpan && parseInt(heartCountSpan.textContent) !== (newPostData.heartCount || 0)) {
                    heartCountSpan.textContent = newPostData.heartCount || 0;
                }
                const funnyCountSpan = postElement.querySelector('.funny-reaction-button .count');
                if (funnyCountSpan && parseInt(funnyCountSpan.textContent) !== (newPostData.funnyCount || 0)) {
                    funnyCountSpan.textContent = newPostData.funnyCount || 0;
                }
                const angryCountSpan = postElement.querySelector('.angry-reaction-button .count');
                if (angryCountSpan && parseInt(angryCountSpan.textContent) !== (newPostData.angryCount || 0)) {
                    angryCountSpan.textContent = newPostData.angryCount || 0;
                }

                const userUID = auth.currentUser?.uid;
                const reactedBy = newPostData.reactedBy || {};
                const userReactions = reactedBy[userUID] || [];

                const heartButton = postElement.querySelector('.heart-reaction-button');
                if (heartButton) heartButton.classList.toggle('active', userReactions.includes('corazón'));
                const funnyButton = postElement.querySelector('.funny-reaction-button');
                if (funnyButton) funnyButton.classList.toggle('active', userReactions.includes('me diverte'));
                const angryButton = postElement.querySelector('.angry-reaction-button');
                if (angryButton) angryButton.classList.toggle('active', userReactions.includes('me enoja'));

                const deleteButton = postElement.querySelector('.delete-button');
                const editButton = postElement.querySelector('.edit-button');
                const canShowEditButton = state.isAdmin || (newPostData.passwordHash && newPostData.authorUID === auth.currentUser?.uid);

                if (deleteButton) deleteButton.style.display = canShowEditButton ? 'inline-flex' : 'none';
                if (editButton) editButton.style.display = canShowEditButton ? 'inline-flex' : 'none';

                const commentsButton = postElement.querySelector('.comments-button');
                if (commentsButton) {
                    const newReplyCount = state.directChildrenCounts[newPostData.id] || 0;
                    const repliesContainerForThisPost = postElement.querySelector(`.replies-container[data-parent-id="${newPostData.id}"]`);
                    const isRepliesVisible = repliesContainerForThisPost ? repliesContainerForThisPost.style.display !== 'none' : false;

                    if (newReplyCount > 0 && currentPostDepth < 3) {
                        commentsButton.style.display = 'inline-flex'; 
                        const commentsButtonCountSpan = commentsButton.querySelector('.count');
                        if (commentsButtonCountSpan) commentsButtonCountSpan.textContent = newReplyCount;
                        
                        if (isRepliesVisible) {
                            commentsButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.973-1.444L2 17l1.62-2.16a8.841 8.841 0 01-1.62-6.836c0-3.866 3.582-7 8-7s8 3.134 8 7z" clip-rule="evenodd" /></svg> Ocultar (<span class="count">${newReplyCount}</span>)`;
                        } else {
                            commentsButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.973-1.444L2 17l1.62-2.16a8.841 8.841 0 01-1.62-6.836c0-3.866 3.582-7 8-7s8 3.134 8 7z" clip-rule="evenodd" /></svg> (<span class="count">${newReplyCount}</span>)`;
                        }
                    } else {
                        commentsButton.style.display = 'none'; 
                    }
                }

                const postIDSpan = postElement.querySelector('.post-id-display');
                if (postIDSpan) {
                    if (currentPostDepth >= 2) {
                        postIDSpan.textContent = `ID: ${newPostData.id.slice(-4)}`;
                        postIDSpan.style.display = 'inline';
                    } else {
                        postIDSpan.style.display = 'none';
                    }
                }

                const replyFormContainer = postElement.querySelector('.reply-form-container');
                if (replyFormContainer) {
                    const isThisPostTheThreadParent = currentPostDepth === 0 && state.viewingThreadId === newPostData.id;
                    setupReplyForm(postElement, newPostData.id, isThisPostTheThreadParent, currentPostDepth);
                }
            }

            async function loadNestedReplies(parentPostId, parentElement, depth) {
                if (depth > 3) return; 

                let repliesContainer = parentElement.querySelector(`.replies-container[data-parent-id="${parentPostId}"]`);
                if (!repliesContainer) {
                    repliesContainer = document.createElement('div');
                    repliesContainer.className = `replies-container ml-4 md:ml-8 mt-4 space-y-4 border-l-2 pl-4`;
                    repliesContainer.style.borderColor = 'var(--divider-color)';
                    repliesContainer.dataset.parentId = parentPostId;
                    parentElement.appendChild(repliesContainer);
                    repliesContainer.style.display = 'block'; 
                }

                let repliesData = [];
                Object.values(state.allPostsData).forEach(p => {
                    if (p.replyTo === parentPostId) {
                        repliesData.push(p);
                    }
                });

                repliesData.sort((a,b) => {
                    const timeA = a.timestamp?.toDate ? a.timestamp.toDate().getTime() : (a.timestamp ? new Date(a.timestamp).getTime() : 0);
                    const timeB = b.timestamp?.toDate ? b.timestamp.toDate().getTime() : (b.timestamp ? new Date(b.timestamp).getTime() : 0);
                    return timeA - timeB; // Orden ascendente (más antiguo primero) para hilos
                });

                const currentReplyElements = new Map();
                Array.from(repliesContainer.children).forEach(child => {
                    if (child.dataset.id) {
                        currentReplyElements.set(child.dataset.id, child);
                    }
                });

                const newReplyIds = new Set(repliesData.map(reply => reply.id));

                for (const [replyId, element] of currentReplyElements) {
                    if (!newReplyIds.has(replyId)) {
                        element.remove();
                        currentReplyElements.delete(replyId);
                    }
                    else {
                        updatePostElement(element, state.allPostsData[replyId], depth);
                    }
                }

                const fragment = document.createDocumentFragment();
                repliesData.forEach(replyData => {
                    let replyElement = currentReplyElements.get(replyData.id);
                    const directChildrenCountForReply = state.directChildrenCounts[replyData.id] || 0;

                    if (!replyElement) { 
                        replyElement = createPostElement(replyData, false, directChildrenCountForReply, depth); 
                        applyPostEffects(replyData, replyElement);
                        currentReplyElements.set(replyData.id, replyElement);
                    }
                    fragment.appendChild(replyElement);
                });

                repliesContainer.innerHTML = '';
                repliesContainer.appendChild(fragment);
                
                for (const replyData of repliesData) {
                    const replyElement = repliesContainer.querySelector(`#post-${replyData.id}`);
                    if (replyElement) {
                       await loadNestedReplies(replyData.id, replyElement, depth + 1);
                    }
                }
            }

            function applyPostEffects(post, element) {
                // Future animations or effects
            }

            function createPostElement(post, isThreadParent = false, replyCount = 0, currentPostDepth = 0) {
                const postElement = document.createElement('div');
                postElement.className = `post p-4 rounded-lg mb-4`; 
                postElement.dataset.id = post.id; 
                postElement.id = `post-${post.id}`;

                if (isThreadParent) {
                    postElement.classList.add('mb-6'); 
                    postElement.style.borderWidth = '2px';
                    postElement.style.borderColor = 'var(--primary-accent-color)';
                }

                const formattedTimestamp = formatPostTimestamp(post.timestamp);
                
                const titleHtml = post.title ? 
                    `<h4 class="post-title"><a href="#board=${post.board}&post=${post.id}" class="post-title-link">${DOMPurify.sanitize(post.title)}</a></h4>` : '';
                const postTextContent = typeof post.text === 'string' ? post.text : '';
                let sanitizedText = DOMPurify.sanitize(postTextContent).replace(/\n/g,'<br>');
                
                sanitizedText = sanitizedText.replace(/&gt;&gt;(\w+)/g, (match, referencedPostIdSuffix) => {
                    const fullReferencedPost = Object.values(state.allPostsData).find(p => p.id.endsWith(referencedPostIdSuffix));
                    const targetPostId = fullReferencedPost ? fullReferencedPost.id : referencedPostIdSuffix;
                    const targetBoard = fullReferencedPost ? fullReferencedPost.board : state.currentBoard; 
                    const threadLinkTargetId = fullReferencedPost ? (fullReferencedPost.replyTo || fullReferencedPost.id) : targetPostId;
                    return `<a href="#board=${targetBoard}&post=${threadLinkTargetId}" class="reply-link" data-post-id="${targetPostId}">>>${referencedPostIdSuffix.slice(-4)}</a>`;
                });

                const contentTextHtml = post.text ? `<div class="post-content text-sm mb-2 mt-1">${sanitizedText}</div>` : '';
                
                const imageClass = state.viewingThreadId ? "max-w-full h-auto object-contain cursor-zoom-in" : "max-w-full h-auto w-full object-cover cursor-zoom-in";
                const contentImageHtml = post.image ? `<div class="post-image-container"><img src="${DOMPurify.sanitize(post.image)}" alt="Imagen del post" class="${imageClass}" loading="lazy"/></div>` : ''; 

                const canShowEditButton = state.isAdmin || (post.passwordHash && post.authorUID === auth.currentUser?.uid);
                
                let replyButtonHtml = '';
                if (currentPostDepth <= 3) {
                    replyButtonHtml = `
                        <button class="reply-button reaction-button" aria-label="Responder a este post">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7.707 3.293a1 1 0 010 1.414L5.414 7H11a7 7 0 017 7v2a1 1 0 11-2 0v-2a5 5 0 00-5-5H5.414l2.293 2.293a1 1 0 11-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                            Responder
                        </button>
                    `;
                }

                let commentsButtonHtml = '';
                const newReplyCount = state.directChildrenCounts[post.id] || 0;
                if (newReplyCount > 0 && currentPostDepth < 3) { 
                    commentsButtonHtml = `
                        <button class="comments-button reaction-button" aria-label="Ver comentarios">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.973-1.444L2 17l1.62-2.16a8.841 8.841 0 01-1.62-6.836c0-3.866 3.582-7 8-7s8 3.134 8 7z" clip-rule="evenodd" /></svg>
                             (<span class="count">${newReplyCount}</span>)
                        </button>`;
                }


                const replyFormHtml = `
                    <div class="reply-form-container post-form-card mt-4 p-4" style="display: none;">
                        <div class="post-input-area mb-2">
                            <div class="avatar reply-avatar"></div>
                            <div class="relative flex-grow">
                                <textarea
                                    class="reply-content w-full focus:ring-0" 
                                    rows="1"
                                    placeholder="Escribe una respuesta..."
                                    aria-label="Contenido de la respuesta"></textarea>
                                <button class="submit-reply icon-button submit-button absolute bottom-2" aria-label="Enviar respuesta">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 16.571V11a1 1 0 112 0v5.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>
                                </button>
                            </div>
                        </div>
                        <div class="post-actions-row">
                            <div class="post-actions-left"></div>
                            <div class="post-actions-right">
                                <label class="reply-file-upload-label icon-button" aria-label="Subir imagen">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" /></svg>
                                    <input type="file" class="reply-file-upload hidden" accept="image/*" aria-hidden="true">
                                </label>
                                <span class="reply-file-name text-xs text-gray-500 ml-2 self-center"></span>
                                
                                <button class="reply-password-toggle icon-button" aria-label="Establecer nombre y contraseña para la respuesta">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M11.078 2.25c-.217-.065-.437-.12-.65-.173a1.75 1.75 0 00-1.946.002c-.213.053-.433.108-.65.173C5.77 3.072 4.5 5.25 4.5 7.5c0 1.97.823 3.717 2.096 4.904.284.344.468.756.528 1.186a3.5 3.5 0 00.878 2.033L9.18 16.06a1.75 1.75 0 002.64 0l.178-.445a3.5 3.5 0 00.878-2.033c.06-.43.243-.842.528-1.186C14.677 11.217 15.5 9.47 15.5 7.5c0-2.25-1.27-4.428-3.344-5.078zM10 9.5a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" /></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                const displayId = currentPostDepth >= 2 ? `inline` : `none`;

                postElement.innerHTML = `
                    <div class="post-header">
                        <div class="post-avatar">${post.avatar}</div>
                        <div class="post-userinfo">
                            <a href="#board=${post.board}&post=${post.id}" class="post-username">${DOMPurify.sanitize(post.name)}</a>
                            <span class="post-timestamp">${formattedTimestamp} ${post.authorUID === auth.currentUser?.uid ? '<span style="color: var(--success-color);">(Tú)</span>' : ''}</span>
                        </div>
                    </div>
                    ${titleHtml}
                    ${contentTextHtml} 
                    ${contentImageHtml}
                    <div class="post-actions">
                        <div class="flex gap-1 items-center flex-wrap"> 
                            <button class="reaction-button heart-reaction-button flex items-center gap-1" aria-label="Reaccionar con Corazón">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" /></svg>
                                <span class="count">${post.heartCount || 0}</span>
                            </button>
                            <button class="reaction-button funny-reaction-button flex items-center gap-1" aria-label="Reaccionar con Me Diverte">
                                😂 <span class="count">${post.funnyCount || 0}</span>
                            </button>
                            <button class="reaction-button angry-reaction-button flex items-center gap-1" aria-label="Reaccionar con Me Enoja">
                                😠 <span class="count">${post.angryCount || 0}</span>
                            </button>
                            ${replyButtonHtml}
                            ${commentsButtonHtml}
                        </div>
                        <div class="flex items-center">
                            ${state.isAdmin || (post.passwordHash && post.authorUID === auth.currentUser?.uid) ? '<button class="delete-button reaction-button delete" aria-label="Eliminar post"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg></button>' : ''}
                            ${canShowEditButton ? `<button class="edit-button reaction-button" aria-label="Editar post"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></svg></button>` : ''}
                            <span class="post-id-display text-xs ml-2" style="color: var(--text-tertiary-color); display: ${displayId};">ID: ${post.id.slice(-4)}</span>
                        </div>
                    </div>
                    ${replyFormHtml} 
                `;

                setupReplyForm(postElement, post.id, false, currentPostDepth); 

                return postElement;
            }

            function setupReplyForm(postElement, parentPostId, shouldStayOpenOnBlur = false, currentPostDepth = 0, isImageViewer = false) {
                const replyFormContainer = postElement.querySelector('.reply-form-container');
                if (!replyFormContainer) return;

                const replyContentTextarea = replyFormContainer.querySelector('.reply-content');
                const replyFileUploadLabel = replyFormContainer.querySelector('.reply-file-upload-label');
                const replyFileUploadInput = replyFormContainer.querySelector('.reply-file-upload');
                const replyFileNameSpan = replyFormContainer.querySelector('.reply-file-name');
                const replyPasswordToggle = replyFormContainer.querySelector('.reply-password-toggle');
                const submitReplyButton = replyFormContainer.querySelector('.submit-reply');
                const replyAvatar = replyFormContainer.querySelector('.reply-avatar'); 

                if (currentPostDepth > 3) {
                    replyFormContainer.style.display = 'none';
                    return;
                }

                let ignoreBlurForFileUpload = false;

                // Limpiar y re-adjuntar listeners
                const newReplyAvatar = replyAvatar.cloneNode(true);
                replyAvatar.parentNode.replaceChild(newReplyAvatar, replyAvatar);
                newReplyAvatar.textContent = newReplyAvatar.dataset.avatar || AVATARS[Math.floor(Math.random() * AVATARS.length)];
                newReplyAvatar.addEventListener('click', () => openProfileEmojiPicker(newReplyAvatar));

                const newReplyContentTextarea = replyContentTextarea.cloneNode(true);
                replyContentTextarea.parentNode.replaceChild(newReplyContentTextarea, replyContentTextarea);
                newReplyContentTextarea.addEventListener('input', autoResizeTextarea);
                newReplyContentTextarea.addEventListener('focus', () => {
                    ignoreBlurForFileUpload = false;
                });
                newReplyContentTextarea.addEventListener('blur', (e) => {
                    const currentText = e.target.value.trim();
                    const hasFile = replyFileUploadInput.files[0]; // Usa el input original aquí
                    if (ignoreBlurForFileUpload) {
                        ignoreBlurForFileUpload = false;
                        return;
                    }
                    if (!shouldStayOpenOnBlur && currentText === '' && !hasFile) {
                        setTimeout(() => {
                            if (e.target.value.trim() === '' && !replyFileUploadInput.files[0] && !state.isPostPasswordModalOpenForReply) { // CORRECCIÓN: Verifica la bandera
                                hideReplyForm(replyFormContainer);
                            }
                        }, 50);
                    }
                });

                const newReplyFileUploadLabel = replyFileUploadLabel.cloneNode(true);
                // Re-insertar el input dentro de la nueva label si es necesario o manejarlo por ID
                const originalInputId = replyFileUploadInput.id || `reply-file-upload-${parentPostId}-${Date.now()}`;
                replyFileUploadInput.id = originalInputId;
                newReplyFileUploadLabel.setAttribute('for', originalInputId);
                replyFileUploadLabel.parentNode.replaceChild(newReplyFileUploadLabel, replyFileUploadLabel);
                newReplyFileUploadLabel.addEventListener('mousedown', () => {
                    ignoreBlurForFileUpload = true;
                });
                
                // El input de archivo original (replyFileUploadInput) sigue siendo el mismo, solo se actualiza su label
                replyFileUploadInput.onchange = null; // Limpiar listener anterior
                replyFileUploadInput.addEventListener('change', () => {
                    replyFileNameSpan.textContent = replyFileUploadInput.files[0] ? replyFileUploadInput.files[0].name : '';
                });


                const newReplyPasswordToggle = replyPasswordToggle.cloneNode(true);
                replyPasswordToggle.parentNode.replaceChild(newReplyPasswordToggle, replyPasswordToggle);
                newReplyPasswordToggle.addEventListener('click', () => openPostPasswordModal(true, parentPostId));

                const newSubmitReplyButton = submitReplyButton.cloneNode(true);
                submitReplyButton.parentNode.replaceChild(newSubmitReplyButton, submitReplyButton);
                newSubmitReplyButton.addEventListener('click', async () => {
                    // Usar los elementos nuevos/actualizados dentro de este handler
                    const currentReplyContentTextareaForSubmit = replyFormContainer.querySelector('.reply-content');
                    const currentReplyFileUploadInputForSubmit = replyFormContainer.querySelector('.reply-file-upload');
                    const currentReplyAvatarForSubmit = replyFormContainer.querySelector('.reply-avatar');

                    const content = currentReplyContentTextareaForSubmit.value.trim();
                    const name = state.tempPostName || "Anónimo"; 
                    const password = state.tempPostPassword; 
                    const file = currentReplyFileUploadInputForSubmit.files[0];

                    if (!content && !file) {
                        showGenericModal("Atención", "El contenido de la respuesta no puede estar vacío si no adjuntas una imagen.", [{ text: 'Entendido', action: closeGenericModal }]);
                        newSubmitReplyButton.disabled = false;
                        newSubmitReplyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 16.571V11a1 1 0 112 0v5.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>`;
                        return;
                    }

                    let targetReplyTo = parentPostId;
                    let initialReplyText = DOMPurify.sanitize(content);

                    if (currentPostDepth === 3) {
                        const parentOfCurrentPost = state.allPostsData[parentPostId];
                        if (parentOfCurrentPost && parentOfCurrentPost.replyTo) {
                            targetReplyTo = parentOfCurrentPost.replyTo; 
                            initialReplyText = `>>${parentPostId.slice(-4)} ${initialReplyText}`; 
                        } else {
                            targetReplyTo = parentPostId; 
                        }
                    }

                    const newReplyData = {
                        authorUID: auth.currentUser.uid,
                        avatar: currentReplyAvatarForSubmit.textContent, 
                        board: state.currentBoard,
                        text: initialReplyText,
                        title: null, 
                        image: null,
                        name: DOMPurify.sanitize(name), 
                        passwordHash: password && bcryptInstance ? bcryptInstance.hashSync(password, 10) : null,
                        heartCount: 0,
                        funnyCount: 0,
                        angryCount: 0,
                        reactedBy: {},
                        timestamp: serverTimestamp(),
                        replyTo: targetReplyTo,
                    };

                    newSubmitReplyButton.disabled = true;
                    newSubmitReplyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 animate-spin" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L9 11.414V15a1 1 0 102 0v-3.586l1.293-1.293a1 1 0 000-1.414z" clip-rule="evenodd" /></svg>`;

                    try {
                        if (file) {
                            if (file.size > MAX_IMAGE_SIZE) {
                                showGenericModal("Error de Archivo", "La imagen es demasiado grande. El tamaño máximo permitido es 4MB.", [{ text: 'Entendido', action: closeGenericModal }]);
                                newSubmitReplyButton.disabled = false;
                                newSubmitReplyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 16.571V11a1 1 0 112 0v5.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>`;
                                return;
                            }
                            const reader = new FileReader();
                            reader.onload = async function(e) {
                                compressImage(e.target.result, async function(compressedImage) {
                                    newReplyData.image = compressedImage;
                                    await addDoc(postsCollectionRef, newReplyData);
                                    resetReplyForm(replyFormContainer, currentReplyAvatarForSubmit, shouldStayOpenOnBlur, isImageViewer);
                                });
                            };
                            reader.onerror = function(e) {
                                console.error("Error del FileReader:", e);
                                showGenericModal("Error de Lectura", "No se pudo leer el archivo de imagen. Intenta de nuevo.", [{ text: 'OK', action: closeGenericModal }]);
                                newSubmitReplyButton.disabled = false;
                                newSubmitReplyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 16.571V11a1 1 0 112 0v5.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>`;
                            };
                            reader.readAsDataURL(file);
                        } else {
                            await addDoc(postsCollectionRef, newReplyData);
                            resetReplyForm(replyFormContainer, currentReplyAvatarForSubmit, shouldStayOpenOnBlur, isImageViewer);
                        }
                            if (state.viewingThreadId) {
                                const opElement = document.querySelector(`#post-${state.viewingThreadId}`);
                                if (opElement) {
                                    const allPostsInBoard = [];
                                    const qAllBoardPosts = query(postsCollectionRef, where("board", "==", state.currentBoard));
                                    const allBoardPostsSnapshot = await getDocs(qAllBoardPosts);
                                    allBoardPostsSnapshot.forEach(d => allPostsInBoard.push({ id: d.id, ...d.data() }));

                                    const tempRepliesByParentForThread = {};
                                    allPostsInBoard.forEach(p => {
                                        if (p.replyTo) {
                                            if (!tempRepliesByParentForThread[p.replyTo]) tempRepliesByParentForThread[p.replyTo] = [];
                                            tempRepliesByParentForThread[p.replyTo].push(p);
                                        }
                                    });
                                    populateDirectCounts(allPostsInBoard, tempRepliesByParentForThread);
                                    await loadNestedReplies(state.viewingThreadId, opElement, 1);
                                }
                            }
                    } catch (error) {
                        console.error("Error en el manejador de clic del botón de enviar respuesta:", error);
                        showGenericModal("Error", "Ocurrió un error al enviar la respuesta. Por favor, inténtalo de nuevo.", [{ text: 'OK', action: closeGenericModal }]);
                    } finally {
                        newSubmitReplyButton.disabled = false;
                        newSubmitReplyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 16.571V11a1 1 0 112 0v5.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>`;
                    }
                });
            }

            function resetReplyForm(formContainer, avatarElement, shouldStayOpenOnBlur, isImageViewer = false) {
                formContainer.querySelector('.reply-content').value = '';
                formContainer.querySelector('.reply-file-upload').value = '';
                formContainer.querySelector('.reply-file-name').textContent = '';
                avatarElement.textContent = AVATARS[Math.floor(Math.random() * AVATARS.length)]; 
                avatarElement.dataset.avatar = avatarElement.textContent;
                state.tempPostName = null;
                state.tempPostTitle = null; 
                state.tempPostPassword = null;
                autoResizeTextarea({ target: formContainer.querySelector('.reply-content') });
                if (!shouldStayOpenOnBlur && !isImageViewer) {
                    hideReplyForm(formContainer);
                }
            }

            function showReplyForm(formContainer, autoFocus = false) {
                if (!state.viewingThreadId) {
                    document.querySelectorAll('.reply-form-container').forEach(form => {
                        if (form !== formContainer) {
                            hideReplyForm(form);
                        }
                    });
                }
                formContainer.style.display = 'block';
                if (autoFocus) {
                    formContainer.querySelector('.reply-content').focus();
                }
                autoResizeTextarea({ target: formContainer.querySelector('.reply-content') });
            }

            function hideReplyForm(formContainer) {
                formContainer.style.display = 'none';
            }

            function showReplyPreview(postId, element) {
                const post = state.allPostsData[postId]; 
                if (!post) {
                    console.warn(`Post ${postId} no encontrado en caché para preview.`);
                    return;
                }
                let tooltip = element.querySelector('.tooltip-text');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.className = 'tooltip-text text-xs p-2';
                    let previewContent = post.image ? "[Imagen]" : (post.text ?? '');
                    if (previewContent.length > 100) previewContent = previewContent.substring(0, 100) + '...';
                    tooltip.innerHTML = `
                        <div class="flex items-center mb-1">
                            <span class="post-avatar text-base mr-1">${post.avatar}</span>
                            <span class="text-xs font-semibold">${DOMPurify.sanitize(post.name)}</span>
                        </div>
                        <div class="text-xs">${DOMPurify.sanitize(previewContent)}</div>`;
                    element.appendChild(tooltip);
                }
            }

            function replyToPost(postId) {
                state.scrollAfterReply = postId; 

                const postElement = document.getElementById(`post-${postId}`);
                if (postElement) {
                    const replyForm = postElement.querySelector('.reply-form-container');
                    if (replyForm) {
                        showReplyForm(replyForm, true);
                    }
                } else {
                    console.error(`Elemento de post con ID ${postId} no encontrado para respuesta.`);
                    window.location.hash = `board=${state.currentBoard}&post=${state.viewingThreadId || postId}`;
                }
            }

            function viewThread(postId) {
                window.location.hash = `board=${state.currentBoard}&post=${postId}`;
            }

            function toggleRepliesVisibility(postId, postElement) {
                let repliesContainer = postElement.querySelector(`.replies-container[data-parent-id="${postId}"]`);
                const commentsButton = postElement.querySelector('.comments-button');

                if (!repliesContainer) {
                    repliesContainer = document.createElement('div');
                    repliesContainer.className = `replies-container ml-4 md:ml-8 mt-4 space-y-4 border-l-2 pl-4`;
                    repliesContainer.style.borderColor = 'var(--divider-color)';
                    repliesContainer.dataset.parentId = postId;
                    postElement.appendChild(repliesContainer);
                    repliesContainer.style.display = 'none'; 
                }

                const isHidden = repliesContainer.style.display === 'none';

                if (isHidden) {
                    repliesContainer.style.display = 'block'; 
                    if(commentsButton) commentsButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.973-1.444L2 17l1.62-2.16a8.841 8.841 0 01-1.62-6.836c0-3.866 3.582-7 8-7s8 3.134 8 7z" clip-rule="evenodd" /></svg> Ocultar (<span class="count">${state.directChildrenCounts[postId] || 0}</span>)`;
                    
                    if (!repliesContainer.dataset.loaded || repliesContainer.dataset.loaded === 'false') {
                        loadNestedReplies(postId, postElement, 1);
                        repliesContainer.dataset.loaded = 'true';
                    }
                } else {
                    repliesContainer.style.display = 'none'; 
                    if(commentsButton) commentsButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.973-1.444L2 17l1.62-2.16a8.841 8.841 0 01-1.62-6.836c0-3.866 3.582-7 8-7s8 3.134 8 7z" clip-rule="evenodd" /></svg> (<span class="count">${state.directChildrenCounts[postId] || 0}</span>)`;
                }
            }
   
            function setupAudioToggle() {
                const audio = document.getElementById('bgAudio');
                const toggleButton = document.getElementById('audioToggle');
                toggleButton.addEventListener('click', () => {
                    state.audioEnabled = !state.audioEnabled;
                    if (state.audioEnabled) {
                        audio.play().catch(e => console.log("Error al reproducir audio:", e));
                        toggleButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M7 4a1 1 0 000 2H4v2a1 1 0 102 0V6h3a1 1 0 100-2H7zM6 8a2 2 0 11-4 0 2 2 0 014 0zM13 4a1 1 0 100 2h3v2a1 1 0 102 0V6h-3a1 1 0 100-2h-3zM14 8a2 2 0 11-4 0 2 2 0 014 0zM4 12a1 1 0 100 2h12a1 1 0 100-2H4z" /></svg>`;
                        toggleButton.style.color = 'var(--primary-accent-color)';
                    } else {
                        audio.pause();
                        toggleButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM12.293 7.293a1 1 0 011.414 0L15 8.586l1.293-1.293a1 1 0 111.414 1.414L16.414 10l1.293 1.293a1 1 0 01-1.414 1.414L15 11.414l-1.293-1.293a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>`;
                        toggleButton.style.color = 'var(--icon-color)';
                    }
                });
            }
            
            function setupFileUpload() {
                const fileInput = document.getElementById('fileUpload');
                fileInput.addEventListener('change', () => {
                    const span = document.getElementById('fileName');
                    span.textContent = fileInput.files[0] ? fileInput.files[0].name : '';
                });
                 const editFileInput = document.getElementById('editFileUpload');
                editFileInput.addEventListener('change', () => {
                    const span = document.getElementById('editFileName');
                    const preview = document.getElementById('editImagePreview');
                    if (editFileInput.files[0]) {
                        span.textContent = editFileInput.files[0].name;
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            preview.src = e.target.result;
                            preview.style.display = 'block';
                        }
                        reader.readAsDataURL(editFileInput.files[0]);
                        document.getElementById('removeCurrentImage').checked = false; 
                    } else {
                        span.textContent = '';
                    }
                });
            }
        
            function changeBoard(board, updateHash = true) {
                state.currentBoard = board;
                document.querySelectorAll('.board-selector').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.board === board);
                });
                
                if (updateHash) { 
                    state.viewingThreadId = null; 
                    window.location.hash = `board=${board}`;
                } else {
                    loadContentForBoard(); 
                }
                updateBoardCoverDisplay(); 
            }

            function adminLogout() {
                state.isAdmin = false;
                localStorage.removeItem('neurochan_admin');
                showGenericModal("Sesión Cerrada", "Has cerrado la sesión de administrador.", [{ text: 'OK', action: closeGenericModal }]);
                document.getElementById('adminLogoutButton').style.display = 'none';
                document.getElementById('settingsToggle')?.classList.remove('text-pink-400'); 
                setupAdminPanel(); 
                loadContentForBoard(); 
                updateBoardCoverDisplay(); 
            }

            async function reactWith(postId, reactionType, reactionField) {
                if (!auth.currentUser) {
                    showGenericModal("Error de Autenticación", "Debes estar conectado para reaccionar. Por favor, recarga la página.", [{ text: 'Entendido', action: closeGenericModal }]);
                    return;
                }
                const userUID = auth.currentUser.uid;
                const postRef = doc(db, "Posts", postId);
                
                try {
                    const postDoc = await getDoc(postRef);
                    if (!postDoc.exists()) {
                        console.error("El post no existe.");
                        return;
                    }
                    const postData = postDoc.data();
                    let userReactions = postData.reactedBy && postData.reactedBy[userUID] ? [...postData.reactedBy[userUID]] : [];
                    const alreadyReacted = userReactions.includes(reactionType);

                    const updates = {};
                    if (alreadyReacted) {
                        userReactions = userReactions.filter(r => r !== reactionType);
                        updates[reactionField] = increment(-1);
                    } else {
                        userReactions.push(reactionType);
                        updates[reactionField] = increment(1);
                    }
                    updates[`reactedBy.${userUID}`] = userReactions; 
                    
                    await updateDoc(postRef, updates);
                } catch (error) {
                    console.error(`Error al reaccionar con ${reactionType}:`, error);
                    showGenericModal("Error de Reacción", "Ocurrió un error al procesar tu reacción.", [{ text: 'OK', action: closeGenericModal }]);
                }
            }

            function reaccionarCorazon(postId) { reactWith(postId, 'corazón', 'heartCount'); }
            function reaccionarMeDiverte(postId) { reactWith(postId, 'me diverte', 'funnyCount'); }
            function reaccionarMeEnoja(postId) { reactWith(postId, 'me enoja', 'angryCount'); }

            function toggleTheme() {
                if (document.body.classList.contains('dark-theme')) {
                    state.currentTheme = 'light'; 
                } else { 
                    state.currentTheme = 'dark';  
                }
                applyCurrentTheme();
                saveThemePreference();
            }

            function updateThemeButtonText() {
                const themeToggle = document.getElementById('themeToggleModalButton'); 
                if (document.body.classList.contains('dark-theme')) {
                    themeToggle.innerHTML = '☀️ Cambiar a Tema Claro';
                } else {
                    themeToggle.innerHTML = '🌙 Cambiar a Tema Oscuro';
                }
            }
            
            function saveThemePreference() {
                localStorage.setItem('neurochan_theme', state.currentTheme);
            }
            
            function applyCurrentTheme() {
                if (state.currentTheme === 'dark') {
                    document.body.classList.add('dark-theme');
                    document.getElementById('themeColorMeta').setAttribute('content', getComputedStyle(document.documentElement).getPropertyValue('--dark-app-bg').trim());
                } else {
                    document.body.classList.remove('dark-theme');
                    document.getElementById('themeColorMeta').setAttribute('content', getComputedStyle(document.documentElement).getPropertyValue('--app-bg').trim());
                }
                updateThemeButtonText();
            }

            async function deletePostFirestore(postId) {
                 if (!auth.currentUser) {
                    showGenericModal("Error de Autenticación", "Debes estar conectado para borrar. Por favor, recarga la página.", [{ text: 'Entendido', action: closeGenericModal }]);
                    return;
                }

                showGenericModal(
                    "Confirmar Borrado",
                    "¿Seguro que quieres borrar este post permanentemente? Esta acción también borrará todas sus respuestas y no se puede deshacer.",
                    [
                        { text: 'Cancelar', class: 'secondary-button', action: closeGenericModal },
                        { text: 'Borrar Definitivamente', class: 'primary-button', style: {backgroundColor: 'var(--danger-color)'}, action: async () => {
                            try { 
                                const deleteNestedReplies = async (parentId) => {
                                    const repliesQuery = query(postsCollectionRef, where("replyTo", "==", parentId));
                                    const repliesSnapshot = await getDocs(repliesQuery);
                                    const deletePromises = [];
                                    for (const docReply of repliesSnapshot.docs) {
                                        await deleteNestedReplies(docReply.id); 
                                        deletePromises.push(deleteDoc(docReply.ref));
                                    }
                                    await Promise.all(deletePromises);
                                };

                                await deleteNestedReplies(postId); 
                                await deleteDoc(doc(db, "Posts", postId)); 
                                
                                closeGenericModal(); 
                                if (state.viewingThreadId === postId) {
                                    window.location.hash = `board=${state.currentBoard}`; 
                                } else if (state.viewingThreadId) {
                                    const opElement = document.querySelector(`#post-${state.viewingThreadId}`);
                                    if (opElement) {
                                        const allPostsInBoard = [];
                                        const qAllBoardPosts = query(postsCollectionRef, where("board", "==", state.currentBoard));
                                        const allBoardPostsSnapshot = await getDocs(qAllBoardPosts);
                                        allBoardPostsSnapshot.forEach(d => allPostsInBoard.push({ id: d.id, ...d.data() }));

                                        const tempRepliesByParentForThread = {};
                                        allPostsInBoard.forEach(p => {
                                            if (p.replyTo) {
                                                if (!tempRepliesByParentForThread[p.replyTo]) tempRepliesByParentForThread[p.replyTo] = [];
                                                tempRepliesByParentForThread[p.replyTo].push(p);
                                            }
                                        });
                                        populateDirectCounts(allPostsInBoard, tempRepliesByParentForThread);
                                        await loadNestedReplies(state.viewingThreadId, opElement, 1);
                                    }
                                }
                            }
                            catch (error) { console.error("Error borrando post y/o respuestas:", error); showGenericModal("Error", "No se pudo borrar el post o sus respuestas.", [{ text: 'OK', action: closeGenericModal }]); }
                        }}
                    ],
                    false 
                );
            }
            
            let currentPostPasswordHash = null;

            function openDeleteModal(postId, passwordHash) {
                state.currentDeletePostId = postId;
                currentPostPasswordHash = passwordHash; 
                document.getElementById('deleteModal').classList.add('flex');
                document.body.classList.add('modal-open'); 
                document.getElementById('deletePasswordInput').value = '';
                document.getElementById('deletePasswordInput').focus();
            }

            function closeDeleteModal() {
                state.currentDeletePostId = null;
                currentPostPasswordHash = null;
                document.getElementById('deleteModal').classList.remove('flex');
                document.body.classList.remove('modal-open'); 
                document.getElementById('deletePasswordInput').value = '';
            }

            async function deletePostWithPassword() {
                if (!auth.currentUser) {
                    showGenericModal("Error de Autenticación", "Debes estar conectado para borrar. Por favor, recarga la página.", [{ text: 'Entendido', action: closeGenericModal }]);
                    closeDeleteModal();
                    return;
                }
                const passwordAttempt = document.getElementById('deletePasswordInput').value;
                if (!state.currentDeletePostId || currentPostPasswordHash === null) { 
                    showGenericModal("Error", "No se puede borrar este post o no requiere contraseña.", [{ text: 'Entendido', action: closeGenericModal }]);
                    closeDeleteModal();
                    return;
                }

                if (bcryptInstance && bcryptInstance.compareSync(passwordAttempt, currentPostPasswordHash)) {
                    await deletePostFirestore(state.currentDeletePostId); 
                    closeDeleteModal(); 
                } else {
                     showGenericModal("Error", "Contraseña incorrecta.", [{ text: 'Entendido', action: () => document.getElementById('deletePasswordInput').focus() }]);
                }
            }

            function openInfoModal() { 
                document.getElementById('infoModal').classList.add('flex'); 
                document.body.classList.add('modal-open'); 
            }
            function closeInfoModal() { 
                document.getElementById('infoModal').classList.remove('flex'); 
                document.body.classList.remove('modal-open'); 
            }
            
            // Se declara globalmente para que el listener en el HTML la encuentre
            window.openSettingsModal = function () {
                const adminLoginBtn = document.getElementById('adminLoginModalButton');
                const adminLogoutBtn = document.getElementById('adminLogoutFromSettingsButton');
                const adminPasswordArea = document.getElementById('adminPasswordInputAreaSettings');

                if (state.isAdmin) {
                    adminLoginBtn.style.display = 'none';
                    adminLogoutBtn.style.display = 'block';
                } else {
                    adminLoginBtn.style.display = 'block';
                    adminLogoutBtn.style.display = 'none';
                }
                adminPasswordArea.style.display = 'none'; 
                document.getElementById('adminPasswordSettingsInput').value = ''; 
                document.getElementById('settingsModal').classList.add('flex');
                document.body.classList.add('modal-open'); 
            }
            function closeSettingsModal() { 
                document.getElementById('settingsModal').classList.remove('flex'); 
                document.body.classList.remove('modal-open'); 
                const adminPasswordArea = document.getElementById('adminPasswordInputAreaSettings');
                if (adminPasswordArea) adminPasswordArea.style.display = 'none';
                const adminLoginBtn = document.getElementById('adminLoginModalButton');
                if (adminLoginBtn && !state.isAdmin) adminLoginBtn.style.display = 'block';
            }
            
            function setupAdminPanel() {
                const adminLogoutBtn = document.getElementById('adminLogoutButton');
                const adminToggleBtn = document.getElementById('settingsToggle'); 
                const boardCoverUploadArea = document.getElementById('boardCoverUploadArea');

                if(state.isAdmin) {
                    if (adminLogoutBtn) adminLogoutBtn.style.display = 'inline-flex'; 
                    if (adminToggleBtn) adminToggleBtn.style.color = 'var(--primary-accent-color)'; 
                    if (boardCoverUploadArea) boardCoverUploadArea.style.display = 'flex'; 
                } else {
                    if (adminLogoutBtn) adminLogoutBtn.style.display = 'none';
                    if (adminToggleBtn) adminToggleBtn.style.color = 'var(--icon-color)';
                    if (boardCoverUploadArea) boardCoverUploadArea.style.display = 'none'; 
                }
            }
         
            function showGenericModal(title, message, buttons = [{ text: 'OK', action: closeGenericModal }], closeModalOnClickOutside = true) {
                const modal = document.getElementById('genericModal');
                document.getElementById('genericModalTitle').textContent = title;
                document.getElementById('genericModalMessage').innerHTML = DOMPurify.sanitize(message); 

                const buttonsContainer = document.getElementById('genericModalButtons');
                buttonsContainer.innerHTML = ''; 

                buttons.forEach(btnConfig => {
                    const button = document.createElement('button');
                    button.textContent = btnConfig.text;
                    let baseClass = 'secondary-button';
                    if (btnConfig.class && btnConfig.class.includes('primary-button')) {
                        baseClass = 'primary-button';
                    } else if (btnConfig.style && btnConfig.style.backgroundColor === 'var(--danger-color)') {
                        baseClass = 'primary-button'; 
                    }
                    
                    button.className = `${baseClass} ${btnConfig.class || ''}`;
                    if (btnConfig.style) { 
                        Object.assign(button.style, btnConfig.style);
                    }

                    button.addEventListener('click', () => {
                        if (btnConfig.action) btnConfig.action();
                    });
                    buttonsContainer.appendChild(button);
                });

                modal.classList.add('flex');
                document.body.classList.add('modal-open'); 

                if (closeModalOnClickOutside) {
                    const closeModalHandler = function(event) {
                        if (event.target === modal) {
                            closeGenericModal();
                            modal.removeEventListener('click', closeModalHandler); 
                        }
                    };
                    modal.addEventListener('click', closeModalHandler);
                } else {
                    modal.onclick = null; 
                }
                modal.querySelectorAll('.generic-modal-close-button').forEach(btn => {
                    btn.addEventListener('click', closeGenericModal);
                });
            }

            function closeGenericModal() { 
                document.getElementById('genericModal').classList.remove('flex'); 
                document.body.classList.remove('modal-open'); 
            }

            function openEditModal(postId) {
                const postToEdit = state.allPostsData[postId]; 
                if (!postToEdit) { showGenericModal("Error", "Post no encontrado para editar.", [{ text: 'OK', action: closeGenericModal }]); return; }

                if (!state.isAdmin && !(postToEdit.passwordHash && postToEdit.authorUID === auth.currentUser?.uid)) {
                    showGenericModal("No Autorizado", "No tienes permiso para editar este post.", [{ text: 'OK', action: closeGenericModal }]);
                    return;
                }

                state.currentEditPostId = postId;
                state.currentEditPostData = { ...postToEdit }; 

                document.getElementById('editPostName').value = postToEdit.name || '';
                document.getElementById('editPostTitle').value = postToEdit.title || ''; 
                document.getElementById('editPostContent').value = postToEdit.text || '';
                
                const imagePreview = document.getElementById('editImagePreview');
                const removeCurrentImageCheckbox = document.getElementById('removeCurrentImage');
                if (postToEdit.image) {
                    imagePreview.src = postToEdit.image;
                    imagePreview.style.display = 'block';
                    removeCurrentImageCheckbox.parentElement.style.display = 'inline-block'; 
                    removeCurrentImageCheckbox.checked = false;
                } else {
                    imagePreview.style.display = 'none';
                    imagePreview.src = '#'; 
                    removeCurrentImageCheckbox.parentElement.style.display = 'none'; 
                }
                document.getElementById('editFileUpload').value = ''; 
                document.getElementById('editFileName').textContent = '';

                const passwordPromptContainer = document.getElementById('editPasswordPromptContainer');
                if (!state.isAdmin && postToEdit.passwordHash) {
                    passwordPromptContainer.style.display = 'block';
                    document.getElementById('editPostPasswordPrompt').value = '';
                    document.getElementById('editPostPasswordPrompt').focus();
                } else {
                    passwordPromptContainer.style.display = 'none';
                }
                document.getElementById('editNewPostPassword').value = '';
                document.getElementById('editModal').classList.add('flex');
                document.body.classList.add('modal-open'); 
            }

            function closeEditModal() {
                document.getElementById('editModal').classList.remove('flex');
                document.body.classList.remove('modal-open'); 
                state.currentEditPostId = null;
                state.currentEditPostData = null;
                document.getElementById('editPostName').value = '';
                document.getElementById('editPostTitle').value = '';
                document.getElementById('editPostContent').value = '';
                document.getElementById('editPostPasswordPrompt').value = '';
                document.getElementById('editNewPostPassword').value = '';
                document.getElementById('editFileUpload').value = '';
                document.getElementById('editFileName').textContent = '';
                document.getElementById('editImagePreview').style.display = 'none';
                document.getElementById('removeCurrentImage').checked = false;
            }

            async function confirmEdit() {
                if (!state.currentEditPostId || !state.currentEditPostData || !auth.currentUser) {
                    showGenericModal("Error", "No se puede editar el post en este momento.", [{ text: 'OK', action: closeGenericModal }]);
                    return;
                }

                const originalPostData = state.currentEditPostData;

                if (!state.isAdmin && originalPostData.passwordHash && originalPostData.authorUID === auth.currentUser.uid) {
                    const passwordAttempt = document.getElementById('editPostPasswordPrompt').value;
                    if (!bcryptInstance || !bcryptInstance.compareSync(passwordAttempt, originalPostData.passwordHash)) {
                        showGenericModal("Error de Edición", "La contraseña del post es incorrecta.", [{ text: 'Entendido', action: () => document.getElementById('editPostPasswordPrompt').focus() }]);
                        return;
                    }
                } else if (!state.isAdmin && originalPostData.authorUID !== auth.currentUser.uid) {
                    showGenericModal("Error de Permiso", "No puedes editar un post que no es tuyo sin ser administrador.", [{ text: 'OK', action: closeGenericModal }]);
                    return;
                }
                
                const updateData = {}; 

                updateData.name = DOMPurify.sanitize(document.getElementById('editPostName').value.trim()) || "Anónimo";
                updateData.title = DOMPurify.sanitize(document.getElementById('editPostTitle').value.trim()) || null; 
                updateData.text = DOMPurify.sanitize(document.getElementById('editPostContent').value.trim());
                
                const newPassword = document.getElementById('editNewPostPassword').value.trim();
                if (newPassword) {
                    if (bcryptInstance) {
                        updateData.passwordHash = bcryptInstance.hashSync(newPassword, 10);
                    } else {
                        showGenericModal("Error de Contraseña", "Bcrypt no está disponible. No se pudo actualizar la contraseña.", [{ text: 'OK', action: closeGenericModal }]);
                    }
                } else {
                    updateData.passwordHash = originalPostData.passwordHash; 
                }
                
                const fileInput = document.getElementById('editFileUpload');
                const removeCurrentImage = document.getElementById('removeCurrentImage').checked;

                const confirmButton = document.getElementById('confirmEdit');
                confirmButton.disabled = true;
                confirmButton.textContent = 'GUARDANDO...';

                if (fileInput.files[0]) {
                    const file = fileInput.files[0];
                    if (file.size > MAX_IMAGE_SIZE) {
                        showGenericModal("Error de Archivo", "La imagen seleccionada es demasiado grande. El máximo es 4MB.", [{ text: 'Entendido', action: closeGenericModal }]);
                        confirmButton.disabled = false;
                        confirmButton.textContent = 'Guardar Cambios';
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = async function(e) {
                        compressImage(e.target.result, async function(compressedImage) {
                            updateData.image = compressedImage;
                            await finalizePostUpdate(updateData, confirmButton);
                        });
                    };
                    reader.readAsDataURL(file);
                } else {
                    if (removeCurrentImage) {
                        updateData.image = null; 
                    } else {
                        updateData.image = originalPostData.image; 
                    }
                    await finalizePostUpdate(updateData, confirmButton);
                }
            }

            async function finalizePostUpdate(updateData, buttonElement) {
                try {
                    updateData.lastEdited = serverTimestamp();
                    await updateDoc(doc(db, "Posts", state.currentEditPostId), updateData);
                    closeEditModal();
                    showGenericModal("Éxito", "El post ha sido actualizado correctamente.", [{ text: 'OK', action: closeGenericModal }]);
                } catch (error) {
                    console.error("Error actualizando post:", error);
                    showGenericModal("Error de Actualización", "No se pudieron guardar los cambios en el post.", [{ text: 'OK', action: closeGenericModal }]);
                } finally {
                    if (buttonElement) { 
                        buttonElement.disabled = false;
                        buttonElement.textContent = 'Guardar Cambios';
                    }
                }
            }

            //openPostPasswordModal
            function openPostPasswordModal(isReply = false, targetPostId = null) {
                let modal = document.getElementById('postPasswordModal'); // Declaración movida al inicio
                if(!modal){
                    console.warn("postPasswordModal not found"); 
                    return;
                }

                const titleElement = document.getElementById('postPasswordModalTitle');
                const messageElement = document.getElementById('postPasswordModalMessage');
                const nameLabel = document.querySelector('#postPasswordModalNameInput').previousElementSibling;
                const nameInput = document.getElementById('postPasswordModalNameInput');
                const titleLabel = document.getElementById('postPasswordModalTitleLabel');
                const titleInput = document.getElementById('postPasswordModalTitleInput'); 
                const passwordInput = document.getElementById('postPasswordModalInput');

                if (isReply) {
                    state.isPostPasswordModalOpenForReply = true; // CORRECCIÓN: Activar bandera
                    titleElement.textContent = "Establecer Nombre y Contraseña";
                    messageElement.textContent = "Establece un nombre (opcional) y una contraseña (opcional) para poder editar o borrar esta respuesta en el futuro.";
                    
                    titleLabel.style.display = 'none';
                    titleInput.style.display = 'none'; // Ocultar campo de título para respuestas
                    titleInput.value = ''; 
                    
                    nameLabel.style.display = 'block';
                    nameInput.style.display = 'block';
                    nameInput.value = state.tempPostName || ''; 
                    passwordInput.value = state.tempPostPassword || ''; 
                    nameInput.focus();
                } else {
                    titleElement.textContent = "Configuración de Post";
                    messageElement.textContent = "Establece tu nombre y título (opcionales) y una contraseña (opcional) para poder editar o borrar este post en el futuro.";
                    
                    titleInput.style.display = 'block'; // Mostrar campo de título para posts principales
                    titleInput.value = state.tempPostTitle || '';
                    
                    nameLabel.style.display = 'block';
                    nameInput.style.display = 'block';
                    nameInput.value = state.tempPostName || '';
                    passwordInput.value = state.tempPostPassword || ''; 
                    nameInput.focus();
                }
                modal.classList.add('flex');
                document.body.classList.add('modal-open'); 
            }

            function closePostPasswordModal() {
                state.isPostPasswordModalOpenForReply = false; // CORRECCIÓN: Desactivar bandera
                document.getElementById('postPasswordModal').classList.remove('flex');
                document.body.classList.remove('modal-open'); 
                if (state.scrollAfterReply) {
                    const targetElement = document.getElementById(`post-${state.scrollAfterReply}`);
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                    state.scrollAfterReply = null; 
                }
            }

            function confirmPostPassword() {
                state.tempPostName = document.getElementById('postPasswordModalNameInput').value.trim();
                state.tempPostTitle = document.getElementById('postPasswordModalTitleInput').value.trim();
                state.tempPostPassword = document.getElementById('postPasswordModalInput').value.trim();
                state.isPostPasswordModalOpenForReply = false; // CORRECCIÓN: Desactivar bandera
                closePostPasswordModal();
            }

            function cancelPostPassword() {
                state.tempPostName = null;
                state.tempPostTitle = null;
                state.tempPostPassword = null;
                state.isPostPasswordModalOpenForReply = false; // CORRECCIÓN: Desactivar bandera
                closePostPasswordModal();
            }

            // --- Funciones del Juego de Tarot ---
            function setupTarotGame() {
                updateUiForView(); 
                state.tarotDeck = [...tarotDeckData]; 
                const spreadContainer = document.getElementById('tarotSpreadContainer');
                const initialCardContainer = document.getElementById('tarotInitialCardContainer');
                const cardInfoDisplay = document.getElementById('tarotCardInfoDisplay');
                
                spreadContainer.innerHTML = ''; 
                if (cardInfoDisplay) cardInfoDisplay.classList.add('hidden');
                if (initialCardContainer) initialCardContainer.classList.remove('hidden');
                
                const tarotDeckCard = document.getElementById('tarotDeckCard');
                if (tarotDeckCard) {
                    tarotDeckCard.classList.remove('spin'); 
                    tarotDeckCard.style.opacity = '1';
                    tarotDeckCard.style.transform = 'rotateY(0deg) scale(1)';
                }
                state.tarotInitialCardFlipped = false;
            }

            function shuffleArray(array) { 
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            async function shuffleAndDealTarot() {
                const initialCardContainer = document.getElementById('tarotInitialCardContainer');
                const tarotDeckCard = document.getElementById('tarotDeckCard');
                const spreadContainer = document.getElementById('tarotSpreadContainer');
                const cardInfoDisplay = document.getElementById('tarotCardInfoDisplay');
                
                if (tarotDeckCard) {
                    tarotDeckCard.classList.add('spin'); 
                    await new Promise(resolve => setTimeout(resolve, 1000)); 
                    if (initialCardContainer) initialCardContainer.classList.add('hidden');
                }

                spreadContainer.innerHTML = '';
                if (cardInfoDisplay) cardInfoDisplay.classList.add('hidden');

                shuffleArray(state.tarotDeck);
                state.tarotSpread = state.tarotDeck.slice(0, 15); 

                let cardIndex = 0;
                const rows = [5, 4, 3, 2, 1]; 
                
                const tarotPositions = [
                    ["Conciencia Pura", "Yo Superior", "Potencial Infinito", "Vacío Cuántico", "Fuente Primordial"], 
                    ["Pasado Profundo", "Lección Actual", "Obstáculo Oculto", "Recurso Interno"], 
                    ["Acción Presente", "Influencia Externa", "Resultado Inminente"], 
                    ["Esperanza Futura", "Miedo Latente"], 
                    ["Esencia del Tema"] 
                ];

                function dealRowSequentially(rowIndex) {
                    if (rowIndex >= rows.length) return; 

                    const numCardsInRow = rows[rowIndex];
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'tarot-row';
                    spreadContainer.appendChild(rowDiv);

                    function dealCardInRowSequentially(cardInRowIndex) {
                        if (cardInRowIndex >= numCardsInRow || cardIndex >= state.tarotSpread.length) {
                            setTimeout(() => dealRowSequentially(rowIndex + 1), 100); 
                            return;
                        }

                        const cardData = state.tarotSpread[cardIndex];
                        const cardElement = document.createElement('div');
                        cardElement.className = 'tarot-card'; 
                        cardElement.dataset.cardIndex = cardIndex; 
                        cardElement.dataset.position = tarotPositions[rowIndex][cardInRowIndex]; 

                        cardElement.innerHTML = `
                            <div class="card-face card-back">🔮</div>
                            <div class="card-face card-front">
                                <img src="${cardData.urlcart}" alt="${DOMPurify.sanitize(cardData.namecart)}" class="tarot-image-display"/>
                                </div>`;
                        
                        cardElement.addEventListener('click', () => flipTarotCard(cardElement, cardData));
                        rowDiv.appendChild(cardElement);
                        
                        void cardElement.offsetWidth; 
                        cardElement.classList.add('placed'); 

                        cardIndex++;
                        setTimeout(() => dealCardInRowSequentially(cardInRowIndex + 1), 150); 
                    }
                    dealCardInRowSequentially(0);
                }
                dealRowSequentially(0); 
            }

            function flipTarotCard(cardElement, cardData) {
                const isCurrentlyFlipped = cardElement.classList.contains('flipped');
                const cardInfoDisplay = document.getElementById('tarotCardInfoDisplay');

                if (isCurrentlyFlipped && cardElement.classList.contains('selected-for-info')) {
                    document.querySelectorAll('.tarot-card.selected-for-info').forEach(c => c.classList.remove('selected-for-info'));
                    cardElement.classList.remove('flipped');
                    if (cardInfoDisplay) cardInfoDisplay.classList.add('hidden');
                    return;
                }

                document.querySelectorAll('.tarot-card.flipped').forEach(c => {
                    if (c !== cardElement) {
                        c.classList.remove('flipped');
                        c.classList.remove('selected-for-info');
                    }
                });
                
                cardElement.classList.add('flipped');
                cardElement.classList.add('selected-for-info');

                document.getElementById('tarotCardNameInfo').textContent = cardData.namecart;
                document.getElementById('tarotCardImageInfo').src = cardData.urlcart;
                document.getElementById('tarotCardImageInfo').alt = DOMPurify.sanitize(cardData.namecart);
                document.getElementById('tarotPositionInfo').textContent = cardElement.dataset.position || 'N/A'; 
                document.getElementById('tarotMeaningUpInfo').textContent = cardData.significado1cart;
                document.getElementById('tarotMeaningRevInfo').textContent = cardData.significado2cart; 
                document.getElementById('tarotQuestionInfo').textContent = cardData.significado3cart; 
                
                if (cardInfoDisplay) cardInfoDisplay.classList.remove('hidden');
            }

            function updateImageViewerReactionsUI(postData) {
                const reactionsContainer = document.getElementById('imageViewerReactionsContainer');
                if (!reactionsContainer) return;

                const userUID = auth.currentUser?.uid;
                const reactedBy = postData.reactedBy || {};
                const userReactions = reactedBy[userUID] || [];

                const heartButton = reactionsContainer.querySelector('.heart-reaction-button');
                const funnyButton = reactionsContainer.querySelector('.funny-reaction-button');
                const angryButton = reactionsContainer.querySelector('.angry-reaction-button');

                if (heartButton) heartButton.querySelector('.count').textContent = postData.heartCount || 0;
                if (funnyButton) funnyButton.querySelector('.count').textContent = postData.funnyCount || 0;
                if (angryButton) angryButton.querySelector('.count').textContent = postData.angryCount || 0;

                if (heartButton) heartButton.classList.toggle('active', userReactions.includes('corazón'));
                if (funnyButton) funnyButton.classList.toggle('active', userReactions.includes('me diverte'));
                if (angryButton) angryButton.classList.toggle('active', userReactions.includes('me enoja'));
            }

            function openImageViewerModal(postId) {
                const post = state.allPostsData[postId];
                if (!post || !post.image) {
                    showGenericModal("Error", "No se encontró la imagen o el post.", [{ text: 'OK', action: closeGenericModal }]);
                    return;
                }

                state.imageViewerCurrentPostId = postId;

                const modal = document.getElementById('imageViewerModal');
                const enlargedImage = modal.querySelector('#enlargedImage');
                const reactionsContainer = modal.querySelector('#imageViewerReactionsContainer');

                enlargedImage.src = DOMPurify.sanitize(post.image);
                enlargedImage.alt = `Imagen de post por ${DOMPurify.sanitize(post.name)}`; 

                updateImageViewerReactionsUI(post);

                if (state.unsubscribeImageViewer) {
                    state.unsubscribeImageViewer(); 
                }
                state.unsubscribeImageViewer = onSnapshot(doc(db, "Posts", postId), (docSnap) => {
                    if (docSnap.exists()) {
                        const updatedPostData = { id: docSnap.id, ...docSnap.data() };
                        state.allPostsData[updatedPostData.id] = updatedPostData; 
                        updateImageViewerReactionsUI(updatedPostData); 
                    } else {
                        console.log("Post para el visor de imágenes ya no existe.");
                        closeImageViewerModal(); 
                    }
                }, (error) => {
                    console.error("Error escuchando post del visor de imágenes:", error);
                });

                let heartButton = reactionsContainer.querySelector('.heart-reaction-button');
                let funnyButton = reactionsContainer.querySelector('.funny-reaction-button');
                let angryButton = reactionsContainer.querySelector('.angry-reaction-button');

                const clonedHeartButton = heartButton.cloneNode(true);
                const clonedFunnyButton = funnyButton.cloneNode(true);
                const clonedAngryButton = angryButton.cloneNode(true); 

                heartButton.parentNode.replaceChild(clonedHeartButton, heartButton);
                funnyButton.parentNode.replaceChild(clonedFunnyButton, funnyButton);
                angryButton.parentNode.replaceChild(clonedAngryButton, angryButton);

                heartButton = clonedHeartButton;
                funnyButton = clonedFunnyButton;
                angryButton = clonedAngryButton;

                heartButton.addEventListener('click', () => reaccionarCorazon(state.imageViewerCurrentPostId));
                funnyButton.addEventListener('click', () => reaccionarMeDiverte(state.imageViewerCurrentPostId));
                angryButton.addEventListener('click', () => reaccionarMeEnoja(state.imageViewerCurrentPostId));

                modal.classList.add('flex');
                document.body.classList.add('modal-open'); 
            }

            function closeImageViewerModal() {
                document.getElementById('imageViewerModal').classList.remove('flex');
                document.body.classList.remove('modal-open'); 
                state.imageViewerCurrentPostId = null;
                if (state.unsubscribeImageViewer) {
                    state.unsubscribeImageViewer(); 
                    state.unsubscribeImageViewer = null;
                }
            }

            function downloadEnlargedImage() {
                const enlargedImage = document.getElementById('enlargedImage');
                const imageUrl = enlargedImage.src;
                if (imageUrl && imageUrl !== '#') {
                    const a = document.createElement('a');
                    a.href = imageUrl;
                    a.download = `neurochan_image_${state.imageViewerCurrentPostId || 'download'}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                } else {
                    showGenericModal("Error de Descarga", "No hay imagen para descargar.", [{ text: 'OK', action: closeGenericModal }]);
                }
            }

            function renderStories() {
                const storiesContainer = document.getElementById('storiesContainer');
                storiesContainer.innerHTML = ''; 

                const imagePostsForStories = Object.values(state.allPostsData).filter(post => post.image);

                const maxStories = 20; 
                const storiesToRender = imagePostsForStories.slice(0, maxStories);

                storiesToRender.forEach(post => {
                    const storyItem = document.createElement('div');
                    storyItem.className = 'story-item';
                    storyItem.dataset.id = post.id;
                    storyItem.innerHTML = `
                        <img src="${DOMPurify.sanitize(post.image)}" alt="Historia de ${DOMPurify.sanitize(post.name)}" class="story-image"/>
                        <div class="story-author-name">${DOMPurify.sanitize(post.name)}</div>
                    `;
                    storyItem.addEventListener('click', () => {
                        viewThread(post.id); 
                    });
                    storiesContainer.appendChild(storyItem);
                });

                let isDragging = false;
                let startX;
                let scrollLeft;

                storiesContainer.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    storiesContainer.classList.add('active');
                    startX = e.pageX - storiesContainer.offsetLeft;
                    scrollLeft = storiesContainer.scrollLeft;
                });

                storiesContainer.addEventListener('mouseleave', () => {
                    isDragging = false;
                    storiesContainer.classList.remove('active');
                });

                storiesContainer.addEventListener('mouseup', () => {
                    isDragging = false;
                    storiesContainer.classList.remove('active');
                });

                storiesContainer.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    const x = e.pageX - storiesContainer.offsetLeft;
                    const walk = (x - startX) * 2; 
                    storiesContainer.scrollLeft = scrollLeft - walk;
                });

                storiesContainer.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    storiesContainer.classList.add('active');
                    startX = e.touches[0].pageX - storiesContainer.offsetLeft;
                    scrollLeft = storiesContainer.scrollLeft;
                }, { passive: true }); 

                storiesContainer.addEventListener('touchend', () => {
                    isDragging = false;
                    storiesContainer.classList.remove('active');
                });

                storiesContainer.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    const x = e.touches[0].pageX - storiesContainer.offsetLeft;
                    const walk = (x - startX) * 2;
                    storiesContainer.scrollLeft = scrollLeft - walk;
                }, { passive: true });
            }

            async function uploadBoardCover() {
                const fileInput = document.getElementById('boardCoverUploadInput');
                const file = fileInput.files[0];
                const loadingIndicator = document.getElementById('boardCoverUploadLoading');

                if (!file) {
                    showGenericModal("Atención", "Por favor, selecciona una imagen para subir.", [{ text: 'OK', action: closeGenericModal }]);
                    return;
                }

                if (file.size > MAX_IMAGE_SIZE) {
                    showGenericModal("Error de Archivo", "La imagen es demasiado grande. El tamaño máximo permitido es 4MB.", [{ text: 'Entendido', action: closeGenericModal }]);
                    return;
                }

                loadingIndicator.classList.remove('hidden');

                try {
                    const reader = new FileReader();
                    reader.onload = async function(e) {
                        compressImage(e.target.result, async function(compressedImage) {
                            if (compressedImage) {
                                await setDoc(doc(coversCollectionRef, state.currentBoard), {
                                    image: compressedImage,
                                    timestamp: serverTimestamp(),
                                    uploadedBy: auth.currentUser.uid
                                });
                                showGenericModal("Éxito", "Portada actualizada correctamente.", [{ text: 'OK', action: closeGenericModal }]);
                            } else {
                                showGenericModal("Error", "No se pudo procesar la imagen.", [{ text: 'OK', action: closeGenericModal }]);
                            }
                            loadingIndicator.classList.add('hidden');
                            fileInput.value = ''; 
                        });
                    };
                    reader.readAsDataURL(file);
                } catch (error) {
                    console.error("Error subiendo portada:", error);
                    showGenericModal("Error", "Ocurrió un error al subir la portada. Inténtalo de nuevo.", [{ text: 'OK', action: closeGenericModal }]);
                    loadingIndicator.classList.add('hidden');
                    fileInput.value = '';
                }
            }

            function updateBoardCoverDisplay() {
                const boardInfoEl = document.getElementById('boardInfo');
                const boardCoverUploadArea = document.getElementById('boardCoverUploadArea');

                if (boardCoverUploadArea) {
                    boardCoverUploadArea.style.display = state.isAdmin ? 'flex' : 'none';
                }

                if (state.unsubscribeCover) {
                    state.unsubscribeCover();
                    state.unsubscribeCover = null;
                }

                const boardData = boards[state.currentBoard] || boards.social; 
                boardInfoEl.style.backgroundImage = `url('${boardData.coverImage}')`;

                const coverDocRef = doc(coversCollectionRef, state.currentBoard);
                state.unsubscribeCover = onSnapshot(coverDocRef, (docSnap) => {
                    if (docSnap.exists() && docSnap.data().image) {
                        boardInfoEl.style.backgroundImage = `url('${DOMPurify.sanitize(docSnap.data().image)}')`;
                    } else {
                        boardInfoEl.style.backgroundImage = `url('${boardData.coverImage}')`;
                    }
                }, (error) => {
                    console.error("Error al obtener la portada del tablero:", error);
                    boardInfoEl.style.backgroundImage = `url('${boardData.coverImage}')`;
                });
            }

            async function openSelectCoverModal() {
                if (!state.isAdmin) {
                    showGenericModal("No Autorizado", "Debes ser administrador para realizar esta acción.", [{ text: 'OK', action: closeGenericModal }]);
                    return;
                }

                const grid = document.getElementById('existingCoversGrid');
                grid.innerHTML = '<p class="text-center text-gray-500 col-span-full">Cargando portadas...</p>';
                document.getElementById('selectCoverModal').classList.add('flex');
                document.body.classList.add('modal-open');

                try {
                    const querySnapshot = await getDocs(coversCollectionRef);
                    state.allCoversData = {}; 
                    grid.innerHTML = ''; 

                    if (querySnapshot.empty) {
                        grid.innerHTML = '<p class="text-center text-gray-500 col-span-full">No hay portadas subidas aún.</p>';
                        return;
                    }

                    querySnapshot.forEach(docSnap => {
                        const coverData = { id: docSnap.id, ...docSnap.data() };
                        state.allCoversData[coverData.id] = coverData;

                        const coverItem = document.createElement('div');
                        coverItem.className = 'relative group cursor-pointer rounded-lg overflow-hidden shadow-md hover:shadow-lg transition-shadow duration-200';
                        coverItem.innerHTML = `
                            <img src="${DOMPurify.sanitize(coverData.image)}" alt="Portada de ${DOMPurify.sanitize(coverData.id)}" class="w-full h-32 object-cover"/>
                            <div class="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200 text-white text-sm font-semibold p-2 text-center">
                                /${DOMPurify.sanitize(coverData.id)}/
                            </div>
                            <button data-cover-id="${coverData.id}" class="delete-cover-button absolute top-1 right-1 bg-red-600 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200" title="Eliminar portada">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.927a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.679-.114 1.022-.165m-1.022.165L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.679-.114 1.022-.165M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.927a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.679-.114 1.022-.165" />
                                </svg>
                            </button>
                        `;
                        coverItem.addEventListener('click', () => selectExistingCover(coverData.id));
                        coverItem.querySelector('.delete-cover-button').addEventListener('click', (e) => {
                            e.stopPropagation(); 
                            openConfirmDeleteCoverModal(coverData.id);
                        });
                        grid.appendChild(coverItem);
                    });
                } catch (error) {
                    console.error("Error al cargar portadas existentes:", error);
                    grid.innerHTML = '<p class="text-center text-red-500 col-span-full">Error al cargar portadas.</p>';
                }
            }

            function closeSelectCoverModal() {
                document.getElementById('selectCoverModal').classList.remove('flex');
                document.body.classList.remove('modal-open');
            }

            async function selectExistingCover(coverId) {
                const coverData = state.allCoversData[coverId];
                if (coverData) {
                    try {
                        await setDoc(doc(coversCollectionRef, state.currentBoard), {
                            image: coverData.image,
                            timestamp: serverTimestamp(),
                            uploadedBy: auth.currentUser.uid 
                        });
                        showGenericModal("Éxito", `Portada del tablero /${state.currentBoard}/ actualizada con la imagen de /${coverId}/.`, [{ text: 'OK', action: closeGenericModal }]);
                        closeSelectCoverModal();
                    } catch (error) {
                        console.error("Error al aplicar portada existente:", error);
                        showGenericModal("Error", "No se pudo aplicar la portada seleccionada.", [{ text: 'OK', action: closeGenericModal }]);
                    }
                } else {
                    showGenericModal("Error", "Portada seleccionada no encontrada.", [{ text: 'OK', action: closeGenericModal }]);
                }
            }

            function openConfirmDeleteCoverModal(coverId) {
                state.currentCoverToDelete = coverId;
                const coverData = state.allCoversData[coverId];
                if (coverData && coverData.image) {
                    document.getElementById('deleteCoverPreview').src = DOMPurify.sanitize(coverData.image);
                    document.getElementById('deleteCoverPreview').style.display = 'block';
                } else {
                    document.getElementById('deleteCoverPreview').style.display = 'none';
                }
                document.getElementById('confirmDeleteCoverModal').classList.add('flex');
                document.body.classList.add('modal-open');
            }

            function closeConfirmDeleteCoverModal() {
                state.currentCoverToDelete = null;
                document.getElementById('confirmDeleteCoverModal').classList.remove('flex');
                document.body.classList.remove('modal-open');
                document.getElementById('deleteCoverPreview').style.display = 'none';
            }

            async function deleteSelectedCover() {
                if (!state.currentCoverToDelete) {
                    showGenericModal("Error", "No hay portada seleccionada para borrar.", [{ text: 'OK', action: closeGenericModal }]);
                    return;
                }
                if (!state.isAdmin) {
                    showGenericModal("No Autorizado", "Debes ser administrador para borrar portadas.", [{ text: 'OK', action: closeGenericModal }]);
                    return;
                }

                try {
                    await deleteDoc(doc(coversCollectionRef, state.currentCoverToDelete));
                    showGenericModal("Éxito", "Portada eliminada correctamente.", [{ text: 'OK', action: closeGenericModal }]);
                    closeConfirmDeleteCoverModal();
                    openSelectCoverModal(); 
                } catch (error) {
                    console.error("Error al borrar portada:", error);
                    showGenericModal("Error", "No se pudo borrar la portada.", [{ text: 'OK', action: closeGenericModal }]);
                }
            }

            function getScrollbarWidth() {
                const outer = document.createElement('div');
                outer.style.visibility = 'hidden';
                outer.style.overflow = 'scroll'; 
                outer.style.msOverflowStyle = 'scrollbar'; 
                document.body.appendChild(outer);
                const inner = document.createElement('div');
                outer.appendChild(inner);
                const scrollbarWidth = (outer.offsetWidth - inner.offsetWidth);
                outer.parentNode.removeChild(outer);
                return scrollbarWidth;
            }

            document.documentElement.style.setProperty('--scrollbar-width', `${getScrollbarWidth()}px`);

        })(); 
    
    // v1.2 click anywhere in post container to open thread (except image and specific buttons)
    document.addEventListener('click', e => {
        const postArticle = e.target.closest('.post'); // Busca el elemento .post más cercano
        if (postArticle && 
            !e.target.closest('.post-image-container') && 
            !e.target.closest('button') && // Ignora clics en cualquier botón dentro del post
            !e.target.closest('a') && // Ignora clics en enlaces (como reply-links o post-title-link)
            !e.target.closest('input') && // Ignora clics en inputs
            !e.target.closest('textarea') && // Ignora clics en textareas
            !e.target.closest('.post-avatar') && // Ignora clics en el avatar
            !e.target.closest('.reply-form-container') // Ignora clics dentro del formulario de respuesta
            ) { 
            const postId = postArticle.dataset.id;
            const boardId = state.currentBoard; // Asume que state.currentBoard está disponible globalmente o pásalo
            if (postId && boardId && !state.viewingThreadId) { // Solo navega si no estamos ya en un hilo
                window.location.hash = `board=${boardId}&post=${postId}`;
            }
        }
    });

</script>
</body>
</html>
